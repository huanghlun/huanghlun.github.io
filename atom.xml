<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric_Blog</title>
  
  <subtitle>Eric&#39;s hexo_blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-14T12:11:07.794Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序解析html</title>
    <link href="http://yoursite.com/2018/01/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90html/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90html/"/>
    <id>http://yoursite.com/2018/01/08/微信小程序解析html/微信小程序解析html/</id>
    <published>2018-01-08T15:08:46.000Z</published>
    <updated>2018-02-14T12:11:07.794Z</updated>
    
    <content type="html"><![CDATA[<p>近日，由于在小程序的开发过程中遇到了解析html标签的问题，发现微信小程序不仅不能自动解析html标签，而且还不能解析动态加载文本中的view标签，于是上网查了许多资料，自己也想了一点办法来解决</p><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>最近在做小程序的一个搜索功能（其实是非常low的搜索），输入一个字段后服务器根据这个字段来进行匹配搜索，然后返回相应的数据，并且在匹配的字段中高亮显示，而这种高亮显示使用了html标签来对字段包含，具体形式如下：（当我在搜索框输入“鲜”来搜索用户时，服务端返回的字段如下）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"nickname"</span> : <span class="string">"&lt;font color=#29abe2&gt;鲜&lt;/font&gt;橙2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(虽然font标签和color属性已经是被人唾弃和淘汰的，但是因为是后端工程师返回的字段和写的协议，所以我们也只能遵循)</em><br></p><p>假如我们直接使用<code></code>绑定该数据在wxml中显示时，微信小程序不会解析该Html标签，而是直接将它当成字符串的形式输出了，效果如下:<br><br><img src="https://i.loli.net/2018/02/14/5a841f6f2a2b8.png" width="400px"><br><br></p><p>因此不能指望小程序自动帮我们解析html标签，要自己想想办法（虽然color中的属性值没用引号’’括起来，但经过试验即使括起来也依然解析不了）</p><h2 id="WxParse"><a href="#WxParse" class="headerlink" title="WxParse"></a>WxParse</h2><p>WxParse是某位前端大牛写的一个插件，详情可以看一下其<a href="https://github.com/icindy/wxParse" target="_blank" rel="noopener">github地址</a>，主要实现是根据正则表达式将各个html标签（包括图片）转成适当的缩进、换行等等</p><blockquote><p>但是，由于如果要使用该插件，要下载其js和wxss等文件，而且工程量不小，自己特别懒，不想为了实现该功能而导入该插件，而且小程序还有代码包的大小限制，因此最终没有使用WxParse。</p></blockquote><h2 id="rich-text"><a href="#rich-text" class="headerlink" title="rich-text"></a>rich-text</h2><blockquote><p>由于不想用网上大牛们写的插件，那么就要自己琢磨一个骚方法出来，因此自己又在小程序的开发文档中再细细地看了目录，发现了一个rich-text富文本编辑组件，顿时就有了灵感</p></blockquote><h3 id="rich-text用法"><a href="#rich-text用法" class="headerlink" title="rich-text用法"></a>rich-text用法</h3><p>rich-text的用法并没有想象中的那么方便暴力，并不是直接在标签之中嵌入html代码，小程序就会帮你自动解析，而是根据其nodes属性值来插入数据，标签之间是不用写数据的，看下<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/rich-text.html" target="_blank" rel="noopener">官方文档</a>的使用说明：<br></p><p><img src="https://i.loli.net/2018/02/14/5a841f700556e.png" width="100%"><br></p><p><img src="https://i.loli.net/2018/02/14/5a841f70b253d.png" width="100%"><br></p><p>乍一看好像挺复杂的，总结一下<strong>其实就是在nodes属性中用数组的形式定义一颗DOM节点树</strong>，并且文本必须由text文本节点包住，考虑一下一开始服务器返回的字段，我们可以将它补全text标签（text表示文本节点），然后对照着想象出DOM树：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DOM结构：</p><ul><li>font<ul><li>text（鲜）</li></ul></li><li>text（橙2）</li></ul><p>根据这个结构，我们可以对照着写进nodes属性，rich-text组件就会解析这个nodes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nodes: [&#123;</span><br><span class="line">    type: <span class="string">'node'</span>,</span><br><span class="line">    name: <span class="string">'font'</span>,</span><br><span class="line">    attrs: &#123; <span class="attr">style</span>: <span class="string">'color: #29abe2'</span> &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: <span class="string">'鲜'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: <span class="string">'橙2'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是，这样还是会遇到问题（虽然这不是rich-text的错，因为本来font标签就不太推荐用了）：</p><ol><li>rich-text组件识别不了已经被淘汰的font节点</li><li>rich-text不能那么智能地将color属性写成style样式</li></ol><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>既然rich-text不能识别这个标签，那我们可以在写进rich-text之前，将这个标签替换成其它的标签，由于font是行内元素，因此我们可用用a、span这两个常用的行内元素来替换掉它，这里我就是用a。并且在替换的过程中我们可以使用style将原本font中的属性放进style中（由于服务器返回的是固定的标签和属性，因此我们也固定style为color:#29abe2即可）。那怎么替换<font>标签呢，自然就是使用<a href="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式</a></font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replaceHTML: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;font[\w#= ]*&gt;/gi</span>, <span class="string">"&lt;a class='search_selected'&gt;"</span>) <span class="comment">//替换&lt;font color=29abe2&gt;标签</span></span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;\/font&gt;/gi</span>, <span class="string">"&lt;/a&gt;"</span>) <span class="comment">//替换&lt;/font&gt;标签</span></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码中我没有直接用style，而是定义了一个叫search_selected的class，下面会讲到怎么使用该class</p><h2 id="问题还没解决"><a href="#问题还没解决" class="headerlink" title="问题还没解决"></a>问题还没解决</h2><blockquote><p>做了上面那么多步，其实问题还没解决，因为你会发现，我们上面一直都是使用静态数据，但我们搜索得到的结果肯定是动态的，每次的结果都是不同的，不会一直都为<code>&lt;font color=#29abe2&gt;鲜&lt;/font&gt;橙2</code>，因此我们需要动态地识别返回来的字符串，然后动态地为rich-text组件生成nodes属性值</p></blockquote><p>在讲整体思路之前，我们要先抛弃掉上面写的replaceHTML函数，那个函数只是为了展示如何替换<font>标签而已，但我们可以利用上面写过的正则表达式来帮助我们搜索<font>标签的位置。</font></font></p><p>解决的整体思路：</p><ol><li>搜索服务器返回的字符串中的<code>&lt;font&gt;</code>标签的位置</li><li>将该位置的索引记录下来，在该位置之前的子字符串即为文本节点，用用text包住push进nodes属性中，然后将该位置的<code>&lt;font&gt;</code>标签成空字符串””</li><li>搜索服务器返回的字符串中的<code>&lt;/font&gt;</code>标签的位置</li><li>在之前记录的<code>&lt;font&gt;</code>标签的位置和<code>&lt;/font&gt;</code>标签位置之间的就是元素节点，即要高亮的部分，这个部分用我们刚才的思想，我们用<code>&lt;a class=&#39;search_selected&#39;&gt;&lt;text&gt;&lt;/text&gt;&lt;/a&gt;</code>元素将该部分包住，然后Push进nodes属性中</li><li>将<code>&lt;/font&gt;</code>标签替换成空字符串’’，在<code>&lt;/font&gt;</code>标签之后子字符串即为文本节点，用用text包住push进nodes属性中</li><li>然后重复以上步骤</li></ol><p>说的非常非常生涩累赘，我们用例子来说明就恍然大悟了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>用我们整体思想，先找到<code>&lt;font&gt;</code>标签，记录其位置，然后它前面的子字符串用<code>&lt;text&gt;</code>包住，由于这里的<code>&lt;font&gt;</code>之前没有子字符串，因此这里跳过。</p><p>然后将<code>&lt;font&gt;</code>标签替换成空字符串:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>找到<code>&lt;/font&gt;</code>标签，根据之前记录的<code>&lt;font&gt;</code>的位置，可以确定它们包围的子字符串为”鲜”，然后用<code>&lt;a class=&#39;search_selected&#39;&gt;&lt;text&lt;/text&gt;&lt;/a&gt;</code>包住该字符串，并且将<code>&lt;/font&gt;</code>标签替换成空字符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'search_selected'</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>之后再把<code>&lt;/font&gt;</code>标签后的字符串用text包围起来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'search_selected'</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于已没有<code>&lt;font&gt;</code>标签了，则不用继续重复了，根据最后得到的这个形式，nodes属性得到的值就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nodes: [&#123;</span><br><span class="line">    type: <span class="string">'node'</span>,</span><br><span class="line">    name: <span class="string">'a'</span>,</span><br><span class="line">    attrs: &#123; <span class="attr">class</span>: <span class="string">'search_selected'</span> &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: <span class="string">'鲜'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: <span class="string">'橙2'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果觉得上面的例子不够生动的话，可以再看这个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 变化前 --&gt;</span></span><br><span class="line">大<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>2<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>橙<span class="tag">&lt;/<span class="name">font</span>&gt;</span>2</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 变化后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>大<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>  <span class="attr">class:</span> '<span class="attr">search_selected</span>'&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>2<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>  <span class="attr">class:</span> '<span class="attr">search_selected</span>'&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后就是JS实现了，其实就十多行的代码，并不复杂，看注释应该就懂了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">replaceHTML: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodes = [], begin_index = <span class="number">-1</span>, end_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (str.search(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>) != <span class="number">-1</span>) &#123; <span class="comment">//如果存在&lt;font&gt;标签则继续循环</span></span><br><span class="line">    begin_index = str.search(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>); <span class="comment">//记录下&lt;font&gt;的位置</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>, <span class="string">""</span>); <span class="comment">//替换&lt;font&gt;为空字符串</span></span><br><span class="line"></span><br><span class="line">    nodes.push(&#123; <span class="comment">//这一步是将&lt;/font&gt;和&lt;font&gt;之间或第一个&lt;font&gt;之前的字符串推入nodes数组中</span></span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: str.substring(end_index == <span class="number">-1</span> ? <span class="number">0</span> : end_index, begin_index)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    end_index = str.search(<span class="regexp">/&lt;\/font&gt;/</span>); <span class="comment">//记录下&lt;/font&gt;的位置</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;\/font&gt;/</span>, <span class="string">""</span>); <span class="comment">//替换&lt;/font&gt;为空字符串</span></span><br><span class="line">    nodes.push(&#123; <span class="comment">//这一步是将&lt;font&gt;和&lt;/font&gt;之间的元素节点推入nodes</span></span><br><span class="line">      name: <span class="string">'a'</span>,</span><br><span class="line">      attrs: &#123; <span class="attr">class</span>: <span class="string">'search_selected'</span> &#125;, <span class="comment">//这里的class会从wxss文件中定义的同名class中寻找样式</span></span><br><span class="line">      children: [&#123;</span><br><span class="line">        type: <span class="string">'text'</span>,</span><br><span class="line">        text: str.substring(begin_index, end_index)</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodes.push(&#123; <span class="comment">//while循环结束后，假如最后一个&lt;/font&gt;标签后还有字符，则将它推入nodes数组中</span></span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: str.substring(end_index, str.length)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>重写replaceHTML后，将rich-text中的nodes属性值绑定我们函数放回的nodes值，rich-text帮我们解析了<code>&lt;a&gt;</code>标签并生成了我们想要的结果<br></p><p><img src="https://i.loli.net/2018/02/14/5a841f70e65e5.png" width="400px"><br></p><p>我们可以看到由原本服务器返回的字符串和相应得到的nodes数组<br></p><p><img src="https://i.loli.net/2018/02/14/5a841f71d207c.png" width="400px"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写的太啰嗦，其中可能也有很多饶了弯的地方，但总体的意思就是替换<code>&lt;font&gt;</code>为<code>&lt;a&gt;</code>标签，然后脑补出一个DOM树将它推入nodes数组，利用rich-text组件将其显示出来。其中如何动态生成整个Nodes数组，或者整个nodes数组中的形式也有很多种，最终能显示出想要的结果就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日，由于在小程序的开发过程中遇到了解析html标签的问题，发现微信小程序不仅不能自动解析html标签，而且还不能解析动态加载文本中的view标签，于是上网查了许多资料，自己也想了一点办法来解决&lt;/p&gt;
&lt;h2 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout</title>
    <link href="http://yoursite.com/2017/12/28/setTimeout/"/>
    <id>http://yoursite.com/2017/12/28/setTimeout/</id>
    <published>2017-12-28T14:19:49.000Z</published>
    <updated>2018-02-18T15:43:47.739Z</updated>
    
    <content type="html"><![CDATA[<p>setTimeout和setInterval是两个js中常用的函数，使用方法很简单，文档介绍得也不难（简陋），但是在实际运用的过程中经常会引发一些bug，所以有必要深究一下这两个函数的作用</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"dosomething"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>非常简单的用法，就是超时调用一个匿名函数，第二个参数就是指定延迟的时间。表面上的意思就是，过1000ms之后执行<code>console.log(&quot;dosomething&quot;)</code>，但是实际上在Javascript的代码运行时，并不代表是过1000ms就执行匿名函数。</p><h3 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h3><blockquote><p>关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。</p><footer><strong>Nicholas C.Zakas</strong><cite>Javascript高级程序设计</cite></footer></blockquote><p>《Javascript高级程序设计》书中有提及到，setTimeout的延迟效果和大部分人意想的效果并不同。<strong>由于Javascript是一个单线程的运行环境，因此所有要执行的代码都放到了一个队列里面</strong>，这个队列也是上述引用说到的队列，我们用代码和图来加以说明。</p><p>考虑以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125;, <span class="number">250</span>);</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，为一个btn元素加入一个onclick的响应函数，在函数中有一部是调用setTimeout延时调用一个匿名函数，当程序在执行setTimeout的时候，它会按照setTimeout的第二个参数定义的时间，在250ms过后将匿名函数放到队列的末尾（<strong>并不一定是250ms后立即执行</strong>），假设btn的onclick函数还有其它的代码要执行，onclick函数的执行时间一共为300ms，那么如下图所示：</p><p><img src="https://i.loli.net/2018/02/18/5a8991c060d3c.png" width="600px"></p><p>若0ms的时候，onclick响应函数被触发执行，然后在5ms的时候，程序执行到setTimeout语句时，它便创建一个定时器，然后在255ms的时候将定时器中的匿名函数的代码添加到队列中，由于此时队列中onclick的响应函数仍未执行完毕，因此setTimeout匿名函数的代码要等到300ms后，onclick执行完毕后才能执行。</p><blockquote><p>从这个例子看出来，setTimeout的作用只是延迟一段时间，将匿名函数添加到队列中，并不是我们理所当然的以为就是简单的过一段时间后马上调用执行该代码。而且，如果onclick函数的执行时间更长，或者在添加定时器代码到队列之前，队列中又被添加了其它需要执行的代码，那么定时器代码的真正执行时间要比设定的250ms长得多，因此这就是调用setTimeout函数引起许多时间上的误差的原因<em>（不过换句说，如果当队列处于完全空闲的状态时，setTimeout函数和我们预想的效果是一样的，就是当定时器代码一被添加到队列时，就被马上执行）</em></p></blockquote><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>一样直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"dosomething"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>用起来和setTimeout函数差不多，只不过setInterval是一个循环调用，表面上达到的效果就是每过1000ms执行一次匿名函数中的<code>console.log(&quot;dosomething&quot;)</code>，但实际上setInterval会比setTimeout更坑，这也是为什么大牛们都推荐用setTimeout来代替setInterval</p><h3 id="setInterval的坑"><a href="#setInterval的坑" class="headerlink" title="setInterval的坑"></a>setInterval的坑</h3><p>假设以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  func(i++);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>如果setInterval匿名函数的执行时间少于100并且执行队列空闲的话，那么一切风平浪静，和预想的效果一样</p><p><img src="https://i.loli.net/2018/02/18/5a8996d105a88.png" width="600px"></p><p>假如匿名函数的时间稍微比100ms大了一点，那么将会造成循环调用的代码需要等待上一次的代码执行完才执行</p><p><img src="https://i.loli.net/2018/02/18/5a899801906f6.png" width="600px"></p><p>可以发现，以上这种情况会导致预想的每100ms执行一次的效果被破坏，实际效果会超过100ms后才会执行第二遍的代码。然而这不是最糟糕的，假如匿名函数中的代码执行时间更长，而在执行的过程中又要创建多个新的等待执行的匿名函数会发生什么情况？</p><blockquote><p>当调用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。</p><footer><strong>Nicholas C.Zakas</strong><cite>Javascript高级程序设计</cite></footer></blockquote><p>这句话的意思是什么呢？我们继续用上面的代码例子来说明，假设第一次调用setInterval创建的匿名函数执行超过了400ms，而在这400ms过程中理应继续创建新的func，但实际上并没有：</p><p><img src="https://i.loli.net/2018/02/18/5a8999c40bcb9.png" width="600px"></p><p>在图示中，在300ms和400ms中有一个垃圾桶的图标，这代表的是在300ms和400ms中被创建的理应被添加到队列中的func函数被丢弃了。这和《Javascript高级程序设计》书中的说法是一致的，我们可以这样理解：<strong>在300ms时，100ms创建的func(1)仍在执行，而200ms创建的func(2)正在队列中等待，由于队列中有一个完整实例func(2)在等待，因此300ms创建的func函数就被丢弃了。到了400ms的时候，情况是相同的。而到了500ms的时候，假设func(1)执行完了，func(2)正在执行，那么500ms创建的func函数就不会被丢弃掉，而是会添加到队列中。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述的代码执行结果我们可以发现，setTimeout函数和setInterval函数都存在一个共同的问题，就是<strong>它们无法保证严格按照传入的第二个参数（延迟时间）来延迟执行</strong>，而且setInterval函数还有一个更可怕的问题就是：<strong>它可能还会丢失一些原本理应按循环执行的函数</strong>，这也是为什么有时候很多动画效果都会用setTimeout代替setInterval去做的原因，即使setTimeout也不一定精确。</p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>正是因为setTimeout和setInterval无法保证执行的时间，所以一个可以保证执行时间的requestAnimationFrame呼之欲出。这个函数基本上就是为了js实现动画而生的，它可以保证函数以60Hz（因为这个是浏览器重绘刷新的极限）的频率进行刷新，但requestAnimationFrame并不是一个完全替代setTimeout和setInterval的函数，因为它无法自己调整函数执行的间隔（延迟）时间，它只能按照浏览器定义的每秒60次的频率去计算间隔时间。</p><p>其基本用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  element.style.left = <span class="built_in">Math</span>.min(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">'px'</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure><blockquote><p>这是选自moz的MDN文档的写法，当然最好还是选用一些兼容性的写法（加入前缀），而且并不是所有版本的浏览器都会返回timestamp的参数（虽然这个参数也没什么用，只是用来返回一个浏览器上一次重绘的时间戳）</p></blockquote><p>requestAnimationFrame的用法看起来其实和setTimeout差不多，只不过requestAnimationFrame需要自己定义一个结束或开始的条件，否则它会一直调用下去。</p><p>因此，setTimeout和setInterval在自定义延迟调用的时候是非常有用的，只不过需要我们弄清楚它的坑而已，而当需要做出一个平稳追求完美的动画时，可以使用requestAnimationFrame来帮助我们，而不再依赖setTimeout函数。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Javascript高级程序设计》</li><li><a href="http://qingbob.com/difference-between-settimeout-setinterval/" target="_blank" rel="noopener">http://qingbob.com/difference-between-settimeout-setinterval/</a> (感谢这位大牛，很多图都选自这里)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;setTimeout和setInterval是两个js中常用的函数，使用方法很简单，文档介绍得也不难（简陋），但是在实际运用的过程中经常会引发一些bug，所以有必要深究一下这两个函数的作用&lt;/p&gt;
&lt;h2 id=&quot;setTimeout&quot;&gt;&lt;a href=&quot;#setTimeo
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>reactJs props和state的区别</title>
    <link href="http://yoursite.com/2017/12/14/react-prop-state/react-prop-state/"/>
    <id>http://yoursite.com/2017/12/14/react-prop-state/react-prop-state/</id>
    <published>2017-12-14T09:11:30.000Z</published>
    <updated>2018-02-14T10:02:59.715Z</updated>
    
    <content type="html"><![CDATA[<p>一开始学习react的时候都会有一个疑惑，就是prop属性和state属性之间的区别是什么，其实网上已经有很多大牛进行了总结，但是如果不自己尝试写一写的话，感觉不会特别地懂。</p><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote><p>Props，即属性(Property)， 在代码中写作 props ， 故可用 props 指代 properties</p></blockquote><p>以上是选自<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">官方文档</a>的一句话，props就是一个react组件中的属性值，可以类比于html元素中的属性。其用法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123; <span class="comment">//函数式组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123; <span class="comment">//类组件</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种组件的等价声明方式，就像构造函数一样，在创建一个组件的时候传入一个参数，该参数就是该组件的props属性值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Eric"</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>以上代码以<a href="http://www.runoob.com/react/react-jsx.html" target="_blank" rel="noopener">JSX</a>语法声明welcome为Welcome组件，并且在创建Welcome组件的时候传入Eric值为其属性name的值。</p><h3 id="props的特性"><a href="#props的特性" class="headerlink" title="props的特性"></a>props的特性</h3><p>从用法可以看出来，props是不能自己创建的，必须是由外部传参而生成的，即不能调用<code>this.props.name=xxx</code>来声明一个name属性值（类似地，就不能调用<code>this.props.name=xxx</code>对props值进行修改），必须是在创建组件的时候从外部指定一个特定的值，如上面代码所示的”Eric”，当然也可以是一个变量值</p><blockquote><p>官方文档里面有说过“props放初始化数据，一直不变的”</p></blockquote><p>其实这句话说的不完全，props不一定一直不变，而是说不能自己改变，官方文档指的“一直不变”的意思是<strong>外部每次传进来的props值，在组件内部是一直不会改变的，除非外部重新传来一个新的props值</strong>（这里下面再详细解释）</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote><p>以上说过props值是不能被自身改变的，因此一个可以被自身改变的值就应运而生，就是state</p></blockquote><p>在这里出现了第一个state和props非常不同的地方，就是state可以被自身改变，其用法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">//声明并初始化state中的值</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数<code>constructor</code>中声明并初始化state值，则可以在return的react组件中绑定state的值。那么如果要改变的话该怎么办呢，就是要使用<code>setState</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">//声明并初始化state中的值</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    <span class="comment">//声明响应函数</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2 onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里添加一个点击响应函数handleClick负责响应h2的点击事件，handleClick中利用setState更新date的时间，当鼠标点击h2标签时，h2中的内容就会相应地改变，这就是state的作用</p><h2 id="Props和state的区别"><a href="#Props和state的区别" class="headerlink" title="Props和state的区别"></a>Props和state的区别</h2><p>到了重点部分，通过列举它们的用法应该可以或多或少看到了props和state的区别了，但是还是要归纳一下，用于理解</p><blockquote><p>props是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件。而state代表的是一个组件内部自身的状态（可以是父组件、子孙组件）</p></blockquote><p>摘自网上大牛的一句话，这句话的意思用代码理解是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">//假设传进来的props中有name</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Container组件中包含着3个Component组件，在传参过程中Component的name值都是由Container传递的，就是说每个组件的props都是由父组件传递过来的，因为自身是没办法创建props属性的，而state属性则是可以自身创建的，我们可以修改下例子也一样可以用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Eric"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.state.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.state.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.state.name&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这说明父组件创建的state值可以通过子组件的props传递给子组件，这也解释了上面大牛说的那句话。</p><p>总结一下，props和state第一个不同就是“props属性是父组件或外部传参传递进来，而state属性是组件自己声明创建的”</p><blockquote><p>props放初始化数据，一直不变的，state就是放要变的</p></blockquote><p>这是大牛说的第二点，理解起来就很容易了，因为上面也有提到过，就是props值自身是没办法改变的，而state值自身就可以通过<code>setState</code>进行修改</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实并不是总结起来发现也不是特别难，好像最后浓缩成了两点</p><ul><li>props不能自身创建，需要外部或父组件传递，state只能由自身创建</li><li>自己的props不能被自己修改，自己的state值则能可以调用<code>setState</code>修改</li></ul><p>其实在使用的时候，props和state经常一起混合使用，比如一些state状态提升之类的状况用法，非常的灵活，还是要多实践敲敲bug才行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始学习react的时候都会有一个疑惑，就是prop属性和state属性之间的区别是什么，其实网上已经有很多大牛进行了总结，但是如果不自己尝试写一写的话，感觉不会特别地懂。&lt;/p&gt;
&lt;h2 id=&quot;Props&quot;&gt;&lt;a href=&quot;#Props&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="reactJs" scheme="http://yoursite.com/tags/reactJs/"/>
    
  </entry>
  
  <entry>
    <title>原生Js和Jquery获取html元素属性的方式</title>
    <link href="http://yoursite.com/2017/12/04/%E5%8E%9F%E7%94%9Fjs%E5%92%8Cjquery%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F/%E5%8E%9F%E7%94%9FJs%E5%92%8CJquery%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/04/原生js和jquery获取元素属性的方式/原生Js和Jquery获取元素属性的方式/</id>
    <published>2017-12-04T14:41:08.000Z</published>
    <updated>2018-02-14T10:03:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>在html里面，html元素属性有很多种，比如img元素自带的就会有src、title、placehold等等属性。当然，html对于自定义属性也是非常的开方，开发者可以随意在html元素里面加任何名字的属性并赋值，或者在js中动态加入，html5还引入了dataset属性来规范自定义属性的声明和使用，但是在Js和Jquery中获取html元素属性的方法有很多种，不同方法得到的效果也不尽相同，因此想深入分析区分一下。</p><h2 id="原生JS获取html元素属性"><a href="#原生JS获取html元素属性" class="headerlink" title="原生JS获取html元素属性"></a>原生JS获取html元素属性</h2><p>先不考虑html5的dataset，考虑以下情况：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span> <span class="attr">xsrc</span>=<span class="string">”img/img.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在原生Javascript有两种获取自定义的xsrc属性的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xscr = img.xsrc; <span class="comment">//无法获取到html元素中的自定义属性</span></span><br><span class="line"><span class="keyword">var</span> xscr = img.getAttribute(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到html元素中的自定义属性</span></span><br><span class="line"><span class="keyword">var</span> src = img.src;</span><br><span class="line"><span class="keyword">var</span> src = img.getAttribute(<span class="string">"src"</span>);</span><br></pre></td></tr></table></figure><p>经试验，只有getAttribute函数时可以获取到img元素中定义的xsrc元素，直接用img.xsrc来访问xsrc属性是不行。但两种方法都可以获取到img原生自带的src属性。</p><h2 id="Jquery获取html元素属性"><a href="#Jquery获取html元素属性" class="headerlink" title="Jquery获取html元素属性"></a>Jquery获取html元素属性</h2><p>还是考虑以上的img元素，jquery获取其元素的方法也是有两种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到写在html元素中的自定义属性</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"xsrc"</span>); <span class="comment">//不可以获取到对象中的自定义属性</span></span><br><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"src"</span>); <span class="comment">//可以获取到写在html元素中的原生属性</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"src"</span>); <span class="comment">//可以获取到对象中的部分原生属性</span></span><br></pre></td></tr></table></figure><p>经过试验可以发现，attr()方法比较强大，它可以获取到html元素中的自定义属性和原生属性，但是prop()方法却无法保证获取到这两种属性（<em>注：prop获取原生属性时，不能百分百返回在html元素中设置的值，比如在获取src值时，它返回的不是xxx，而是文件路径+xxx，但当获取title值时，却能正确返回，因此在获取html元素中的原生属性时，尽量不要使用prop元素</em>）</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h3 id="动态加入自定义属性"><a href="#动态加入自定义属性" class="headerlink" title="动态加入自定义属性"></a>动态加入自定义属性</h3><p>其实以上获取的自定义属性都是在html元素中定义好的，那还有一种情况就是没有在html元素中提前定义好，而是用js动态为某个html元素对象定义属性，那么在这种情况下，该怎么获取到这个自定义属性?</p><p>考虑以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line">img.hsrc = <span class="string">"ssss"</span>;</span><br></pre></td></tr></table></figure><p>我在JS中利用DOM获取到img元素的Element对象，然后为这个对象动态地加入hsrc属性，并赋值为ssss，此时我再用上述的所有方法获取该自定义属性值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hsrc = img.hsrc; <span class="comment">//可以获取到hsrc值</span></span><br><span class="line"><span class="keyword">var</span> hsrc = img.getAttribute(<span class="string">"hsrc"</span>); <span class="comment">//不能获取到hsrc值</span></span><br><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"xsrc"</span>); <span class="comment">//不能获取到hsrc值</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到hsrc值</span></span><br></pre></td></tr></table></figure><p>经试验发现，只有prop()方法和直接获取元素的方法可以访问到js动态声明的属性值，而attr()方法和getAttribute()方法都无法访问到该属性</p><h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p>可能是由于这种自定义元素的获取容易混淆，所以html5加入了一个dataset来规范自定义元素的声明，不过dataset是一个只读的属性，它一般只用来在html元素中使用data-*来声明自定义属性，不能用来动态新增或修改属性值，其用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-xsrc</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>获取时，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xsrc = img.dataset.xsrc;</span><br><span class="line"><span class="keyword">var</span> xsrc = $(<span class="string">"img"</span>).data(<span class="string">"xsrc"</span>);</span><br></pre></td></tr></table></figure><p>刚说过原生的dataset属性是一个只读属性，但是Jquery的data函数不仅是可读的，而且是可写，用法就是在第二个参数中传入一个新的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).data(<span class="string">"xsrc"</span>, <span class="string">"1231123"</span>); <span class="comment">//不仅可以修改一个属性值，还可以创建一个属性值</span></span><br></pre></td></tr></table></figure><p>这种情况下，data函数的原理是什么呢？既然原生js中dataset属性是只读的，那么data()函数就不是通过dataset属性来实现的，而且data()函数不是真正的修改html元素里的data-*属性，而是通过覆盖已存在的值，只有再调用data()函数取相同name的属性时，才会得到新的覆盖的值，removeData()可以将这个新的覆盖值删掉，实例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"1231"</span> xsrc=<span class="string">"xixixi"</span> title=<span class="string">"111"</span> data-xtitle=<span class="string">"110"</span>&gt;</span><br><span class="line">$(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>, <span class="string">"123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>)); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(img.dataset.xtitle); <span class="comment">//110</span></span><br><span class="line">$(<span class="string">"img"</span>).removeData(<span class="string">"xtitle"</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>));  <span class="comment">//110</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>原生js：<ul><li>img.xsrc无法获取到html元素中的自定义属性</li><li>img.getAttribute(“xsrc”)可以获取到html元素中的自定义属性</li></ul></li><li>Jquery：<ul><li>$(img).attr(“xrc”)可以获取到写在html元素中的自定义属性</li><li>$(img).prop(“xrc”)可以获取到对象中的自定义属性</li></ul></li></ol><p>在js代码中为某个html的对象动态定义属性时，如img.hsrc=”xxx”时，img.hsrc可以直接获取到该自定义属性，$(img).prop(“hsrc”)也可以获取到，其它两个不行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在html里面，html元素属性有很多种，比如img元素自带的就会有src、title、placehold等等属性。当然，html对于自定义属性也是非常的开方，开发者可以随意在html元素里面加任何名字的属性并赋值，或者在js中动态加入，html5还引入了dataset属性
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
  <entry>
    <title>getBoundingClient</title>
    <link href="http://yoursite.com/2017/11/11/getBoundingClient/getBoundingClientRect/"/>
    <id>http://yoursite.com/2017/11/11/getBoundingClient/getBoundingClientRect/</id>
    <published>2017-11-11T04:49:55.000Z</published>
    <updated>2018-02-14T11:34:27.205Z</updated>
    
    <content type="html"><![CDATA[<p>对于DOM中的盒模型，学习前端的人肯定再熟悉不过，在盒模型中除了margin、padding这些基本的值以外，还会有offsetTop、offsetLeft、clientTop、clientLeft这些值，但其实还有一个容易让人忽略，但非常实用的值或者说函数，就是getBoundingClient</p><h2 id="getBoundingClient语法"><a href="#getBoundingClient语法" class="headerlink" title="getBoundingClient语法"></a>getBoundingClient语法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rectObject = object.getBoundingClientRect();</span><br></pre></td></tr></table></figure><p>返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合 。</p><p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rectLeft = object.getBoundingClientRect().left;</span><br><span class="line">rectRight = object.getBoundingClientRect().right;</span><br><span class="line">rectTop = object.getBoundingClientRect().top;</span><br><span class="line">rectBottom = object.getBoundingClientRect().bottom;</span><br></pre></td></tr></table></figure><h3 id="比较offsetTop、offsetLeft"><a href="#比较offsetTop、offsetLeft" class="headerlink" title="比较offsetTop、offsetLeft"></a>比较offsetTop、offsetLeft</h3><blockquote><p>刚刚上面提到了getBoundingClientRect()返回的值都是相对视口而言的，那么我们就会想起offsetLeft、offsetTop，那么这两个属性有什么不同呢，还是说它们就是一样的呢？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 400px; background-color: #aaa; margin: 40px;"</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().top); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().left); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetTop); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetLeft); <span class="comment">//40</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在body元素下直接定义了一个class为test的div标签，然后输出div的top、left值和offsetTop和offsetLeft的值发现它们都是40，那是不是说明它们是一样的呢？我们修改一下代码看看</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 400px; margin: 40px; position: relative;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 100%; background-color: #aaa;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().top); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().left); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetTop); <span class="comment">//0</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetLeft); <span class="comment">//0</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到，此时offsetTop和offsetLeft都会变成了0，因为test_div有了一个非static布局的父元素（<strong>注意一定是非static布局的父元素，否则offsetTop和offsetLet依然是会穿过这个父元素，得到的是相对于整个document文档的偏移量</strong>），所以可以发现offsetTop和offsetLeft得到的是当前元素相对于第一个非static布局的祖先元素的偏移值。而getBoundingClientRect()得到的top、left值则依然是40，因此可以进一步说明getBoundingClientRect()是相对于视口的，和它的父元素无关。</p><blockquote><p>那么如果还是以第一个例子为例，当div元素是body的直接子元素时，offsetTop和getBoundingClientRect().top得到的值就完全相同了吗，此时都是相对于视口而言的吗？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; div.length; ++i) &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].getBoundingClientRect().top);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].getBoundingClientRect().left);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].offsetTop);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].offsetLeft);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>都过试验，可以发现它们的值都是一样的，但如果到了这里就断定它们是一样的那就错了，因为现在页面没有滚动，当页面有滚动的时候会发生什么情况？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"pagescrollTop: "</span> + <span class="built_in">document</span>.documentElement.scrollTop); <span class="comment">//100</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"test_div top:"</span> + test_div.getBoundingClientRect().top); <span class="comment">//-60</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"test_div offsetTop"</span> + test_div.offsetTop); <span class="comment">//40</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改了输出的代码，以第一个div作为观察对象，当页面出现滚动时，可能会出现以下现象，页面向下滚动了100的距离，此时test_div的top值为-60，而offsetTop的值依然为40，大家可以参照下面的图理解下此时的情况，此时test_div的上边缘已经超出了视口，在视口的上方，上边缘与视口上方的距离为60，而整个文档页面的上边缘也超出了视口，根据页面的滚动值可以知道，此时文档页面的上边缘超出视口的距离为100，而offsetTop的值就是test_div在文档页面的偏移量，因此不会改变，一直为40</p><p><img src="https://i.loli.net/2018/02/14/5a841eb3ba9c2.jpg" alt="example"><br></p><p>因此，比较出它们两者的区别:</p><ul><li>getBoundingClient()是相对于视口的偏移量，和它的父元素无关，不仅可以取正值，当超出视口上边缘的时候，可以取到负值</li><li>offsetTop和offseLeft是相对于第一个非static的祖先元素的偏移量，它是一个静态固定的值，除非文档重绘，否则它不会改变，一般为正值，除了margin为负值的情况</li></ul><h2 id="getBoundingClient-的真正用途"><a href="#getBoundingClient-的真正用途" class="headerlink" title="getBoundingClient()的真正用途"></a>getBoundingClient()的真正用途</h2><blockquote><p>上面说了如此多都是在介绍getBoundingClient()的语法，还有和offset的区别，但仅仅知道这些是不够的，还需要知道getBoundingClient常用在什么情况</p></blockquote><p>在瀑布流的布局中，常常会有两种情况，要么是当文档滚动触底的时候，动态加载一些新的图片并追加一下img元素，要么就是预先已经追加了很多img元素和其对应的图片路径，但只有当img元素出现在视口中时才开始加载图片。</p><ul><li>对于第一种情况，利用document.documentElement.offsetHeight、document.documentElement.scrollTop和document.documentElement.clientHeight（或document.body.clientHeight）就可以判断触底然后加载，不需要用到getBoundingClient()</li><li>对于第二种情况，就需要监听当页面在滚动时，判断每个img元素是否已经处于视口中，这种情况getBoundingClient()就十分有用了</li></ul><p>先上代码，其实并不难</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; ++i) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(imgs[i].getBoundingClient().top &gt;=<span class="number">0</span> &amp;&amp; imgs[i].getBoundingClient.top &lt;= <span class="built_in">document</span>.documentElement.clientHeight) &#123; <span class="comment">//判断在视口中</span></span></span><br><span class="line"><span class="javascript">          imgs[i].src = imgs[i].getAttribute(<span class="string">"xsrc"</span>); <span class="comment">//赋值给src</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们假设我们已经用ajax或者其它方式请求到了多个图片的路径，然后我们动态地将img元素追加到了文档中，但是我们不立即设置img元素的src值为该图片路径，而是将这个路径值存在img元素的xsrc属性中（属性名可以自己定义，无关紧要）。因为我们知道<strong>给img设置src值后就会马上向服务器请求改图像的资源</strong>，假如图片很多并且都很大，就会很耗费资源，所以可以考虑，只有当我们滚动页面显示到了对应的img元素时才将src设为对应的图像路径去请求资源，这样就会相对减少不必要的请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>getBoundingClient()函数只要是用于返回一个元素的rect矩形模型对于视口的top、left、right、bottom值，我们可以利用getBoundingClient函数来实现判断一个元素是否处于视口中，即当前是否被显示在浏览器的窗口中，从而进行一系列的操作，比如将图片加载出来等等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于DOM中的盒模型，学习前端的人肯定再熟悉不过，在盒模型中除了margin、padding这些基本的值以外，还会有offsetTop、offsetLeft、clientTop、clientLeft这些值，但其实还有一个容易让人忽略，但非常实用的值或者说函数，就是getBo
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Jquery css()引来的误解</title>
    <link href="http://yoursite.com/2017/11/02/Jquery-css/Jquery-css/"/>
    <id>http://yoursite.com/2017/11/02/Jquery-css/Jquery-css/</id>
    <published>2017-11-02T08:35:59.000Z</published>
    <updated>2018-02-14T11:36:48.352Z</updated>
    
    <content type="html"><![CDATA[<p>由于一开始学习web前端，就去使用Jquery框架了，因此就导致自己对原生js的一些语法产生了误解，留下了很多坑，当自己抛弃Jquery，想用原生的js去写一个简单的网站时就出现了很多问题，其中在动态获取改变元素样式时就遇到了一个值得markdown的问题。</p><h2 id="Jquery-css"><a href="#Jquery-css" class="headerlink" title="Jquery css()"></a>Jquery css()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>); <span class="comment">//获取第一个p元素的color样式值</span></span><br><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>, <span class="string">"red"</span>); <span class="comment">//设置第一个p元素的样式值为red</span></span><br></pre></td></tr></table></figure><p>Jquery.css()获取和设置某个元素的样式，语法很简单</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们知道在DOM标准中，获取元素style的值有两种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.style;</span><br><span class="line"><span class="built_in">document</span>.defaultView.getComputedStyle(element, <span class="literal">null</span>); <span class="comment">//第二个参数指的是伪类，如果不是伪类一般设为null</span></span><br></pre></td></tr></table></figure><p>由此，会出现两个问题：第一个问题是Jquery的css函数其实是原生js的哪种方法包装而成的？第二个问题是原生Js中这两种获取元素style的方法有什么实质性的不同？（而作为一个菜鸟，很可能自然地会以为css()函数就相当于element.style获取样式，两者的效果一样，但事实并不是这样的，也有可能根本不知道getComputedStyle函数的存在）</p><h2 id="Element-style和getComputedStyle"><a href="#Element-style和getComputedStyle" class="headerlink" title="Element.style和getComputedStyle"></a>Element.style和getComputedStyle</h2><h3 id="用法区别"><a href="#用法区别" class="headerlink" title="用法区别"></a>用法区别</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test css<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">p &#123;</span></span><br><span class="line"><span class="undefined">color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>测试style和getComputed<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color); <span class="comment">//输出为空</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">document</span>.defaultView.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>], <span class="literal">null</span>).color); <span class="comment">//rgb(255, 0, 0)</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先解决的是第二个问题，就是这两种样式获取方法的区别在哪，不难发现其实Element.style.color获取到的是行内的样式值（<strong>这真的是个老是坑基础不牢新手的地方，我就被坑了很多次，style值是无法获取到非行内设置的样式值的</strong>），而getComputedStyle是获取到某个元素的全部计算后的样式（计算后的代表不同优先级的同一样式值会取优先级最高的），因此上面的输出style.color由于p元素中没有设置color值，因此输出为空，而getComputedStyle则输出了红色的rgb表示</p><h3 id="比较Jquery-css"><a href="#比较Jquery-css" class="headerlink" title="比较Jquery.css()"></a>比较Jquery.css()</h3><p>回到第一个问题，不妨在上面代码的基础上再加入一行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color); <span class="comment">//输出为空</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.defaultView.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>], <span class="literal">null</span>).color); <span class="comment">//或用getPropertyValue（"color"） 输出rgb(255, 0, 0)</span></span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"p"</span>).css(<span class="string">"color"</span>)); <span class="comment">//rgb(255, 0, 0)</span></span><br></pre></td></tr></table></figure><p>使用css()函数获取到的是rgb(255, 0, 0)，这证明了当<strong>获取样式值</strong>的时候，css()函数其实是和getComputedStyle()元素是一样的。由于getComputedStyle得到的样式值都是只读的，因此我们接下来只要验证一下当用css()函数设置样式值时，是否和element.style设置样式的作用一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color = green;</span><br><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>, <span class="string">"green"</span>)</span><br></pre></td></tr></table></figure><p>试验之后发现得到的结果都是一样的：<br><br></p><p><img src="https://i.loli.net/2018/02/14/5a841f316c34f.png" alt="img"> <br></p><p>因此，两者在设置样式的效果都是一样的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Jquery.css()函数并不是与原生js的element.style一样的！Jquery.css()函数并不是与原生js的element.style一样的！Jquery.css()函数并不是与原生js的element.style一样的！（重要事情说三遍）</p><ul><li>获取样式时，css()函数与getComputedStyle()函数效果相同（不考虑伪类的情况下，css()函数无法获取伪类样式）</li><li>设置样式时，css()函数与element.style效果相同</li></ul><p>对于一个合格的前端程序员来说，还是要多啃啃书（比如《Javascript权威指南》、《Javascript高级编程》），好好学习一下js，不能只是一个只会用框架的人，“要学会做一个造轮子的人”</p><p><em>补充：既然说到了获取样式，其实在IE9以下的版本，IE只支持currentStyle来实现getComputedStyle的功能（但currentStyle获取不了伪类的样式），但由于currentStyle没有列入DOM标准，这里只说到了DOM标准的两种方法，而IE9已经支持DOM标准了。Jquery框架在前几个版本兼容了IE浏览器的几个较低的版本，而最新的版本已经进行IE低版本(IE6、IE7、IE8)的兼容性处理</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于一开始学习web前端，就去使用Jquery框架了，因此就导致自己对原生js的一些语法产生了误解，留下了很多坑，当自己抛弃Jquery，想用原生的js去写一个简单的网站时就出现了很多问题，其中在动态获取改变元素样式时就遇到了一个值得markdown的问题。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
</feed>
