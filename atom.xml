<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric_Blog</title>
  
  <subtitle>Eric&#39;s hexo_blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-13T14:19:56.214Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>getBoundingClient</title>
    <link href="http://yoursite.com/2018/02/11/getBoundingClientRect/"/>
    <id>http://yoursite.com/2018/02/11/getBoundingClientRect/</id>
    <published>2018-02-11T04:49:55.000Z</published>
    <updated>2018-02-13T14:19:56.214Z</updated>
    
    <content type="html"><![CDATA[<p>对于DOM中的盒模型，学习前端的人肯定再熟悉不过，在盒模型中除了margin、padding这些基本的值以外，还会有offsetTop、offsetLeft、clientTop、clientLeft这些值，但其实还有一个容易让人忽略，但非常实用的值或者说函数，就是getBoundingClient</p><h2 id="getBoundingClient语法"><a href="#getBoundingClient语法" class="headerlink" title="getBoundingClient语法"></a>getBoundingClient语法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rectObject = object.getBoundingClientRect();</span><br></pre></td></tr></table></figure><p>返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合 。</p><p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rectLeft = object.getBoundingClientRect().left;</span><br><span class="line">rectRight = object.getBoundingClientRect().right;</span><br><span class="line">rectTop = object.getBoundingClientRect().top;</span><br><span class="line">rectBottom = object.getBoundingClientRect().bottom;</span><br></pre></td></tr></table></figure><h3 id="比较offsetTop、offsetLeft"><a href="#比较offsetTop、offsetLeft" class="headerlink" title="比较offsetTop、offsetLeft"></a>比较offsetTop、offsetLeft</h3><blockquote><p>刚刚上面提到了getBoundingClientRect()返回的值都是相对视口而言的，那么我们就会想起offsetLeft、offsetTop，那么这两个属性有什么不同呢，还是说它们就是一样的呢？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 400px; background-color: #aaa; margin: 40px;"</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().top); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().left); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetTop); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetLeft); <span class="comment">//40</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在body元素下直接定义了一个class为test的div标签，然后输出div的top、left值和offsetTop和offsetLeft的值发现它们都是40，那是不是说明它们是一样的呢？我们修改一下代码看看</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 400px; margin: 40px; position: relative;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 100%; background-color: #aaa;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().top); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().left); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetTop); <span class="comment">//0</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetLeft); <span class="comment">//0</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到，此时offsetTop和offsetLeft都会变成了0，因为test_div有了一个非static布局的父元素（<strong>注意一定是非static布局的父元素，否则offsetTop和offsetLet依然是会穿过这个父元素，得到的是相对于整个document文档的偏移量</strong>），所以可以发现offsetTop和offsetLeft得到的是当前元素相对于第一个非static布局的祖先元素的偏移值。而getBoundingClientRect()得到的top、left值则依然是40，因此可以进一步说明getBoundingClientRect()是相对于视口的，和它的父元素无关。</p><blockquote><p>那么如果还是以第一个例子为例，当div元素是body的直接子元素时，offsetTop和getBoundingClientRect().top得到的值就完全相同了吗，此时都是相对于视口而言的吗？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; div.length; ++i) &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].getBoundingClientRect().top);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].getBoundingClientRect().left);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].offsetTop);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].offsetLeft);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>都过试验，可以发现它们的值都是一样的，但如果到了这里就断定它们是一样的那就错了，因为现在页面没有滚动，当页面有滚动的时候会发生什么情况？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"pagescrollTop: "</span> + <span class="built_in">document</span>.documentElement.scrollTop); <span class="comment">//100</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"test_div top:"</span> + test_div.getBoundingClientRect().top); <span class="comment">//-60</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"test_div offsetTop"</span> + test_div.offsetTop); <span class="comment">//40</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改了输出的代码，以第一个div作为观察对象，当页面出现滚动时，可能会出现以下现象，页面向下滚动了100的距离，此时test_div的top值为-60，而offsetTop的值依然为40，大家可以参照下面的图理解下此时的情况，此时test_div的上边缘已经超出了视口，在视口的上方，上边缘与视口上方的距离为60，而整个文档页面的上边缘也超出了视口，根据页面的滚动值可以知道，此时文档页面的上边缘超出视口的距离为100，而offsetTop的值就是test_div在文档页面的偏移量，因此不会改变，一直为40</p><p><img src="/2018/02/11/getBoundingClientRect/getBoundingClient/example.jpg" alt="example"><br></p><p>因此，比较出它们两者的区别:</p><ul><li>getBoundingClient()是相对于视口的偏移量，和它的父元素无关，不仅可以取正值，当超出视口上边缘的时候，可以取到负值</li><li>offsetTop和offseLeft是相对于第一个非static的祖先元素的偏移量，它是一个静态固定的值，除非文档重绘，否则它不会改变，一般为正值，除了margin为负值的情况</li></ul><h2 id="getBoundingClient-的真正用途"><a href="#getBoundingClient-的真正用途" class="headerlink" title="getBoundingClient()的真正用途"></a>getBoundingClient()的真正用途</h2><blockquote><p>上面说了如此多都是在介绍getBoundingClient()的语法，还有和offset的区别，但仅仅知道这些是不够的，还需要知道getBoundingClient常用在什么情况</p></blockquote><p>在瀑布流的布局中，常常会有两种情况，要么是当文档滚动触底的时候，动态加载一些新的图片并追加一下img元素，要么就是预先已经追加了很多img元素和其对应的图片路径，但只有当img元素出现在视口中时才开始加载图片。</p><ul><li>对于第一种情况，利用document.documentElement.offsetHeight、document.documentElement.scrollTop和document.documentElement.clientHeight（或document.body.clientHeight）就可以判断触底然后加载，不需要用到getBoundingClient()</li><li>对于第二种情况，就需要监听当页面在滚动时，判断每个img元素是否已经处于视口中，这种情况getBoundingClient()就十分有用了</li></ul><p>先上代码，其实并不难</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; ++i) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(imgs[i].getBoundingClient().top &gt;=<span class="number">0</span> &amp;&amp; imgs[i].getBoundingClient.top &lt;= <span class="built_in">document</span>.documentElement.clientHeight) &#123; <span class="comment">//判断在视口中</span></span></span><br><span class="line"><span class="javascript">          imgs[i].src = imgs[i].getAttribute(<span class="string">"xsrc"</span>); <span class="comment">//赋值给src</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们假设我们已经用ajax或者其它方式请求到了多个图片的路径，然后我们动态地将img元素追加到了文档中，但是我们不立即设置img元素的src值为该图片路径，而是将这个路径值存在img元素的xsrc属性中（属性名可以自己定义，无关紧要）。因为我们知道<strong>给img设置src值后就会马上向服务器请求改图像的资源</strong>，假如图片很多并且都很大，就会很耗费资源，所以可以考虑，只有当我们滚动页面显示到了对应的img元素时才将src设为对应的图像路径去请求资源，这样就会相对减少不必要的请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>getBoundingClient()函数只要是用于返回一个元素的rect矩形模型对于视口的top、left、right、bottom值，我们可以利用getBoundingClient函数来实现判断一个元素是否处于视口中，即当前是否被显示在浏览器的窗口中，从而进行一系列的操作，比如将图片加载出来等等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于DOM中的盒模型，学习前端的人肯定再熟悉不过，在盒模型中除了margin、padding这些基本的值以外，还会有offsetTop、offsetLeft、clientTop、clientLeft这些值，但其实还有一个容易让人忽略，但非常实用的值或者说函数，就是getBo
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序解析html</title>
    <link href="http://yoursite.com/2018/02/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90html/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90html/"/>
    <id>http://yoursite.com/2018/02/08/微信小程序解析html/微信小程序解析html/</id>
    <published>2018-02-08T15:08:46.000Z</published>
    <updated>2018-02-13T14:21:13.699Z</updated>
    
    <content type="html"><![CDATA[<p>近日，由于在小程序的开发过程中遇到了解析html标签的问题，发现微信小程序不仅不能自动解析html标签，而且还不能解析动态加载文本中的view标签，于是上网查了许多资料，自己也想了一点办法来解决</p><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>最近在做小程序的一个搜索功能（其实是非常low的搜索），输入一个字段后服务器根据这个字段来进行匹配搜索，然后返回相应的数据，并且在匹配的字段中高亮显示，而这种高亮显示使用了html标签来对字段包含，具体形式如下：（当我在搜索框输入“鲜”来搜索用户时，服务端返回的字段如下）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"nickname"</span> : <span class="string">"&lt;font color=#29abe2&gt;鲜&lt;/font&gt;橙2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(虽然font标签和color属性已经是被人唾弃和淘汰的，但是因为是后端工程师返回的字段和写的协议，所以我们也只能遵循)</em><br></p><p>假如我们直接使用<code></code>绑定该数据在wxml中显示时，微信小程序不会解析该Html标签，而是直接将它当成字符串的形式输出了，效果如下:<br><br><img src="/2018/02/08/微信小程序解析html/微信小程序解析html/wx_1.png" width="400px"><br><br></p><p>因此不能指望小程序自动帮我们解析html标签，要自己想想办法（虽然color中的属性值没用引号’’括起来，但经过试验即使括起来也依然解析不了）</p><h2 id="WxParse"><a href="#WxParse" class="headerlink" title="WxParse"></a>WxParse</h2><p>WxParse是某位前端大牛写的一个插件，详情可以看一下其<a href="https://github.com/icindy/wxParse" target="_blank" rel="noopener">github地址</a>，主要实现是根据正则表达式将各个html标签（包括图片）转成适当的缩进、换行等等</p><blockquote><p>但是，由于如果要使用该插件，要下载其js和wxss等文件，而且工程量不小，自己特别懒，不想为了实现该功能而导入该插件，而且小程序还有代码包的大小限制，因此最终没有使用WxParse。</p></blockquote><h2 id="rich-text"><a href="#rich-text" class="headerlink" title="rich-text"></a>rich-text</h2><blockquote><p>由于不想用网上大牛们写的插件，那么就要自己琢磨一个骚方法出来，因此自己又在小程序的开发文档中再细细地看了目录，发现了一个rich-text富文本编辑组件，顿时就有了灵感</p></blockquote><h3 id="rich-text用法"><a href="#rich-text用法" class="headerlink" title="rich-text用法"></a>rich-text用法</h3><p>rich-text的用法并没有想象中的那么方便暴力，并不是直接在标签之中嵌入html代码，小程序就会帮你自动解析，而是根据其nodes属性值来插入数据，标签之间是不用写数据的，看下<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/rich-text.html" target="_blank" rel="noopener">官方文档</a>的使用说明：<br></p><p><img src="/2018/02/08/微信小程序解析html/微信小程序解析html/wx_2.png" width="100%"><br></p><p><img src="/2018/02/08/微信小程序解析html/微信小程序解析html/wx_3.png" width="100%"><br></p><p>乍一看好像挺复杂的，总结一下<strong>其实就是在nodes属性中用数组的形式定义一颗DOM节点树</strong>，并且文本必须由text文本节点包住，考虑一下一开始服务器返回的字段，我们可以将它补全text标签（text表示文本节点），然后对照着想象出DOM树：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DOM结构：</p><ul><li>font<ul><li>text（鲜）</li></ul></li><li>text（橙2）</li></ul><p>根据这个结构，我们可以对照着写进nodes属性，rich-text组件就会解析这个nodes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nodes: [&#123;</span><br><span class="line">    type: <span class="string">'node'</span>,</span><br><span class="line">    name: <span class="string">'font'</span>,</span><br><span class="line">    attrs: &#123; <span class="attr">style</span>: <span class="string">'color: #29abe2'</span> &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: <span class="string">'鲜'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: <span class="string">'橙2'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是，这样还是会遇到问题（虽然这不是rich-text的错，因为本来font标签就不太推荐用了）：</p><ol><li>rich-text组件识别不了已经被淘汰的font节点</li><li>rich-text不能那么智能地将color属性写成style样式</li></ol><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>既然rich-text不能识别这个标签，那我们可以在写进rich-text之前，将这个标签替换成其它的标签，由于font是行内元素，因此我们可用用a、span这两个常用的行内元素来替换掉它，这里我就是用a。并且在替换的过程中我们可以使用style将原本font中的属性放进style中（由于服务器返回的是固定的标签和属性，因此我们也固定style为color:#29abe2即可）。那怎么替换<font>标签呢，自然就是使用<a href="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式</a></font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replaceHTML: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;font[\w#= ]*&gt;/gi</span>, <span class="string">"&lt;a class='search_selected'&gt;"</span>) <span class="comment">//替换&lt;font color=29abe2&gt;标签</span></span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;\/font&gt;/gi</span>, <span class="string">"&lt;/a&gt;"</span>) <span class="comment">//替换&lt;/font&gt;标签</span></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码中我没有直接用style，而是定义了一个叫search_selected的class，下面会讲到怎么使用该class</p><h2 id="问题还没解决"><a href="#问题还没解决" class="headerlink" title="问题还没解决"></a>问题还没解决</h2><blockquote><p>做了上面那么多步，其实问题还没解决，因为你会发现，我们上面一直都是使用静态数据，但我们搜索得到的结果肯定是动态的，每次的结果都是不同的，不会一直都为<code>&lt;font color=#29abe2&gt;鲜&lt;/font&gt;橙2</code>，因此我们需要动态地识别返回来的字符串，然后动态地为rich-text组件生成nodes属性值</p></blockquote><p>在讲整体思路之前，我们要先抛弃掉上面写的replaceHTML函数，那个函数只是为了展示如何替换<font>标签而已，但我们可以利用上面写过的正则表达式来帮助我们搜索<font>标签的位置。</font></font></p><p>解决的整体思路：</p><ol><li>搜索服务器返回的字符串中的<code>&lt;font&gt;</code>标签的位置</li><li>将该位置的索引记录下来，在该位置之前的子字符串即为文本节点，用用text包住push进nodes属性中，然后将该位置的<code>&lt;font&gt;</code>标签成空字符串””</li><li>搜索服务器返回的字符串中的<code>&lt;/font&gt;</code>标签的位置</li><li>在之前记录的<code>&lt;font&gt;</code>标签的位置和<code>&lt;/font&gt;</code>标签位置之间的就是元素节点，即要高亮的部分，这个部分用我们刚才的思想，我们用<code>&lt;a class=&#39;search_selected&#39;&gt;&lt;text&gt;&lt;/text&gt;&lt;/a&gt;</code>元素将该部分包住，然后Push进nodes属性中</li><li>将<code>&lt;/font&gt;</code>标签替换成空字符串’’，在<code>&lt;/font&gt;</code>标签之后子字符串即为文本节点，用用text包住push进nodes属性中</li><li>然后重复以上步骤</li></ol><p>说的非常非常生涩累赘，我们用例子来说明就恍然大悟了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>用我们整体思想，先找到<code>&lt;font&gt;</code>标签，记录其位置，然后它前面的子字符串用<code>&lt;text&gt;</code>包住，由于这里的<code>&lt;font&gt;</code>之前没有子字符串，因此这里跳过。</p><p>然后将<code>&lt;font&gt;</code>标签替换成空字符串:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>找到<code>&lt;/font&gt;</code>标签，根据之前记录的<code>&lt;font&gt;</code>的位置，可以确定它们包围的子字符串为”鲜”，然后用<code>&lt;a class=&#39;search_selected&#39;&gt;&lt;text&lt;/text&gt;&lt;/a&gt;</code>包住该字符串，并且将<code>&lt;/font&gt;</code>标签替换成空字符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'search_selected'</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>之后再把<code>&lt;/font&gt;</code>标签后的字符串用text包围起来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'search_selected'</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于已没有<code>&lt;font&gt;</code>标签了，则不用继续重复了，根据最后得到的这个形式，nodes属性得到的值就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nodes: [&#123;</span><br><span class="line">    type: <span class="string">'node'</span>,</span><br><span class="line">    name: <span class="string">'a'</span>,</span><br><span class="line">    attrs: &#123; <span class="attr">class</span>: <span class="string">'search_selected'</span> &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: <span class="string">'鲜'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: <span class="string">'橙2'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果觉得上面的例子不够生动的话，可以再看这个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 变化前 --&gt;</span></span><br><span class="line">大<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>2<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>橙<span class="tag">&lt;/<span class="name">font</span>&gt;</span>2</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 变化后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>大<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>  <span class="attr">class:</span> '<span class="attr">search_selected</span>'&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>2<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>  <span class="attr">class:</span> '<span class="attr">search_selected</span>'&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后就是JS实现了，其实就十多行的代码，并不复杂，看注释应该就懂了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">replaceHTML: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodes = [], begin_index = <span class="number">-1</span>, end_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (str.search(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>) != <span class="number">-1</span>) &#123; <span class="comment">//如果存在&lt;font&gt;标签则继续循环</span></span><br><span class="line">    begin_index = str.search(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>); <span class="comment">//记录下&lt;font&gt;的位置</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>, <span class="string">""</span>); <span class="comment">//替换&lt;font&gt;为空字符串</span></span><br><span class="line"></span><br><span class="line">    nodes.push(&#123; <span class="comment">//这一步是将&lt;/font&gt;和&lt;font&gt;之间或第一个&lt;font&gt;之前的字符串推入nodes数组中</span></span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: str.substring(end_index == <span class="number">-1</span> ? <span class="number">0</span> : end_index, begin_index)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    end_index = str.search(<span class="regexp">/&lt;\/font&gt;/</span>); <span class="comment">//记录下&lt;/font&gt;的位置</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;\/font&gt;/</span>, <span class="string">""</span>); <span class="comment">//替换&lt;/font&gt;为空字符串</span></span><br><span class="line">    nodes.push(&#123; <span class="comment">//这一步是将&lt;font&gt;和&lt;/font&gt;之间的元素节点推入nodes</span></span><br><span class="line">      name: <span class="string">'a'</span>,</span><br><span class="line">      attrs: &#123; <span class="attr">class</span>: <span class="string">'search_selected'</span> &#125;, <span class="comment">//这里的class会从wxss文件中定义的同名class中寻找样式</span></span><br><span class="line">      children: [&#123;</span><br><span class="line">        type: <span class="string">'text'</span>,</span><br><span class="line">        text: str.substring(begin_index, end_index)</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodes.push(&#123; <span class="comment">//while循环结束后，假如最后一个&lt;/font&gt;标签后还有字符，则将它推入nodes数组中</span></span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: str.substring(end_index, str.length)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>重写replaceHTML后，将rich-text中的nodes属性值绑定我们函数放回的nodes值，rich-text帮我们解析了<code>&lt;a&gt;</code>标签并生成了我们想要的结果<br></p><p><img src="/2018/02/08/微信小程序解析html/微信小程序解析html/wx_4.png" width="400px"><br></p><p>我们可以看到由原本服务器返回的字符串和相应得到的nodes数组<br></p><p><img src="/2018/02/08/微信小程序解析html/微信小程序解析html/wx_5.png" width="400px"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写的太啰嗦，其中可能也有很多饶了弯的地方，但总体的意思就是替换<code>&lt;font&gt;</code>为<code>&lt;a&gt;</code>标签，然后脑补出一个DOM树将它推入nodes数组，利用rich-text组件将其显示出来。其中如何动态生成整个Nodes数组，或者整个nodes数组中的形式也有很多种，最终能显示出想要的结果就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日，由于在小程序的开发过程中遇到了解析html标签的问题，发现微信小程序不仅不能自动解析html标签，而且还不能解析动态加载文本中的view标签，于是上网查了许多资料，自己也想了一点办法来解决&lt;/p&gt;
&lt;h2 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>原生Js和Jquery获取html元素属性的方式</title>
    <link href="http://yoursite.com/2018/02/04/%E5%8E%9F%E7%94%9Fjs%E5%92%8Cjquery%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F/%E5%8E%9F%E7%94%9FJs%E5%92%8CJquery%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/02/04/原生js和jquery获取元素属性的方式/原生Js和Jquery获取元素属性的方式/</id>
    <published>2018-02-04T14:41:08.000Z</published>
    <updated>2018-02-13T14:20:35.828Z</updated>
    
    <content type="html"><![CDATA[<p>在html里面，html元素属性有很多种，比如img元素自带的就会有src、title、placehold等等属性。当然，html对于自定义属性也是非常的开方，开发者可以随意在html元素里面加任何名字的属性并赋值，或者在js中动态加入，html5还引入了dataset属性来规范自定义属性的声明和使用，但是在Js和Jquery中获取html元素属性的方法有很多种，不同方法得到的效果也不尽相同，因此想深入分析区分一下。</p><h2 id="原生JS获取html元素属性"><a href="#原生JS获取html元素属性" class="headerlink" title="原生JS获取html元素属性"></a>原生JS获取html元素属性</h2><p>先不考虑html5的dataset，考虑以下情况：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span> <span class="attr">xsrc</span>=<span class="string">”img/img.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在原生Javascript有两种获取自定义的xsrc属性的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xscr = img.xsrc; <span class="comment">//无法获取到html元素中的自定义属性</span></span><br><span class="line"><span class="keyword">var</span> xscr = img.getAttribute(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到html元素中的自定义属性</span></span><br><span class="line"><span class="keyword">var</span> src = img.src;</span><br><span class="line"><span class="keyword">var</span> src = img.getAttribute(<span class="string">"src"</span>);</span><br></pre></td></tr></table></figure><p>经试验，只有getAttribute函数时可以获取到img元素中定义的xsrc元素，直接用img.xsrc来访问xsrc属性是不行。但两种方法都可以获取到img原生自带的src属性。</p><h2 id="Jquery获取html元素属性"><a href="#Jquery获取html元素属性" class="headerlink" title="Jquery获取html元素属性"></a>Jquery获取html元素属性</h2><p>还是考虑以上的img元素，jquery获取其元素的方法也是有两种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到写在html元素中的自定义属性</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"xsrc"</span>); <span class="comment">//不可以获取到对象中的自定义属性</span></span><br><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"src"</span>); <span class="comment">//可以获取到写在html元素中的原生属性</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"src"</span>); <span class="comment">//可以获取到对象中的部分原生属性</span></span><br></pre></td></tr></table></figure><p>经过试验可以发现，attr()方法比较强大，它可以获取到html元素中的自定义属性和原生属性，但是prop()方法却无法保证获取到这两种属性（<em>注：prop获取原生属性时，不能百分百返回在html元素中设置的值，比如在获取src值时，它返回的不是xxx，而是文件路径+xxx，但当获取title值时，却能正确返回，因此在获取html元素中的原生属性时，尽量不要使用prop元素</em>）</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h3 id="动态加入自定义属性"><a href="#动态加入自定义属性" class="headerlink" title="动态加入自定义属性"></a>动态加入自定义属性</h3><p>其实以上获取的自定义属性都是在html元素中定义好的，那还有一种情况就是没有在html元素中提前定义好，而是用js动态为某个html元素对象定义属性，那么在这种情况下，该怎么获取到这个自定义属性?</p><p>考虑以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line">img.hsrc = <span class="string">"ssss"</span>;</span><br></pre></td></tr></table></figure><p>我在JS中利用DOM获取到img元素的Element对象，然后为这个对象动态地加入hsrc属性，并赋值为ssss，此时我再用上述的所有方法获取该自定义属性值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hsrc = img.hsrc; <span class="comment">//可以获取到hsrc值</span></span><br><span class="line"><span class="keyword">var</span> hsrc = img.getAttribute(<span class="string">"hsrc"</span>); <span class="comment">//不能获取到hsrc值</span></span><br><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"xsrc"</span>); <span class="comment">//不能获取到hsrc值</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到hsrc值</span></span><br></pre></td></tr></table></figure><p>经试验发现，只有prop()方法和直接获取元素的方法可以访问到js动态声明的属性值，而attr()方法和getAttribute()方法都无法访问到该属性</p><h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p>可能是由于这种自定义元素的获取容易混淆，所以html5加入了一个dataset来规范自定义元素的声明，不过dataset是一个只读的属性，它一般只用来在html元素中使用data-*来声明自定义属性，不能用来动态新增或修改属性值，其用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-xsrc</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>获取时，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xsrc = img.dataset.xsrc;</span><br><span class="line"><span class="keyword">var</span> xsrc = $(<span class="string">"img"</span>).data(<span class="string">"xsrc"</span>);</span><br></pre></td></tr></table></figure><p>刚说过原生的dataset属性是一个只读属性，但是Jquery的data函数不仅是可读的，而且是可写，用法就是在第二个参数中传入一个新的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).data(<span class="string">"xsrc"</span>, <span class="string">"1231123"</span>); <span class="comment">//不仅可以修改一个属性值，还可以创建一个属性值</span></span><br></pre></td></tr></table></figure><p>这种情况下，data函数的原理是什么呢？既然原生js中dataset属性是只读的，那么data()函数就不是通过dataset属性来实现的，而且data()函数不是真正的修改html元素里的data-*属性，而是通过覆盖已存在的值，只有再调用data()函数取相同name的属性时，才会得到新的覆盖的值，removeData()可以将这个新的覆盖值删掉，实例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"1231"</span> xsrc=<span class="string">"xixixi"</span> title=<span class="string">"111"</span> data-xtitle=<span class="string">"110"</span>&gt;</span><br><span class="line">$(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>, <span class="string">"123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>)); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(img.dataset.xtitle); <span class="comment">//110</span></span><br><span class="line">$(<span class="string">"img"</span>).removeData(<span class="string">"xtitle"</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>));  <span class="comment">//110</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>原生js：<ul><li>img.xsrc无法获取到html元素中的自定义属性</li><li>img.getAttribute(“xsrc”)可以获取到html元素中的自定义属性</li></ul></li><li>Jquery：<ul><li>$(img).attr(“xrc”)可以获取到写在html元素中的自定义属性</li><li>$(img).prop(“xrc”)可以获取到对象中的自定义属性</li></ul></li></ol><p>在js代码中为某个html的对象动态定义属性时，如img.hsrc=”xxx”时，img.hsrc可以直接获取到该自定义属性，$(img).prop(“hsrc”)也可以获取到，其它两个不行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在html里面，html元素属性有很多种，比如img元素自带的就会有src、title、placehold等等属性。当然，html对于自定义属性也是非常的开方，开发者可以随意在html元素里面加任何名字的属性并赋值，或者在js中动态加入，html5还引入了dataset属性
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
  <entry>
    <title>Jquery css()引来的误解</title>
    <link href="http://yoursite.com/2018/02/02/Jquery-css/Jquery-css/"/>
    <id>http://yoursite.com/2018/02/02/Jquery-css/Jquery-css/</id>
    <published>2018-02-02T08:35:59.000Z</published>
    <updated>2018-02-13T14:19:50.477Z</updated>
    
    <content type="html"><![CDATA[<p>由于一开始学习web前端，就去使用Jquery框架了，因此就导致自己对原生js的一些语法产生了误解，留下了很多坑，当自己抛弃Jquery，想用原生的js去写一个简单的网站时就出现了很多问题，其中在动态获取改变元素样式时就遇到了一个值得markdown的问题。</p><h2 id="Jquery-css"><a href="#Jquery-css" class="headerlink" title="Jquery css()"></a>Jquery css()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>); <span class="comment">//获取第一个p元素的color样式值</span></span><br><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>, <span class="string">"red"</span>); <span class="comment">//设置第一个p元素的样式值为red</span></span><br></pre></td></tr></table></figure><p>Jquery.css()获取和设置某个元素的样式，语法很简单</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们知道在DOM标准中，获取元素style的值有两种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.style;</span><br><span class="line"><span class="built_in">document</span>.defaultView.getComputedStyle(element, <span class="literal">null</span>); <span class="comment">//第二个参数指的是伪类，如果不是伪类一般设为null</span></span><br></pre></td></tr></table></figure><p>由此，会出现两个问题：第一个问题是Jquery的css函数其实是原生js的哪种方法包装而成的？第二个问题是原生Js中这两种获取元素style的方法有什么实质性的不同？（而作为一个菜鸟，很可能自然地会以为css()函数就相当于element.style获取样式，两者的效果一样，但事实并不是这样的，也有可能根本不知道getComputedStyle函数的存在）</p><h2 id="Element-style和getComputedStyle"><a href="#Element-style和getComputedStyle" class="headerlink" title="Element.style和getComputedStyle"></a>Element.style和getComputedStyle</h2><h3 id="用法区别"><a href="#用法区别" class="headerlink" title="用法区别"></a>用法区别</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test css<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">p &#123;</span></span><br><span class="line"><span class="undefined">color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>测试style和getComputed<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color); <span class="comment">//输出为空</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">document</span>.defaultView.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>], <span class="literal">null</span>).color); <span class="comment">//rgb(255, 0, 0)</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先解决的是第二个问题，就是这两种样式获取方法的区别在哪，不难发现其实Element.style.color获取到的是行内的样式值（<strong>这真的是个老是坑基础不牢新手的地方，我就被坑了很多次，style值是无法获取到非行内设置的样式值的</strong>），而getComputedStyle是获取到某个元素的全部计算后的样式（计算后的代表不同优先级的同一样式值会取优先级最高的），因此上面的输出style.color由于p元素中没有设置color值，因此输出为空，而getComputedStyle则输出了红色的rgb表示</p><h3 id="比较Jquery-css"><a href="#比较Jquery-css" class="headerlink" title="比较Jquery.css()"></a>比较Jquery.css()</h3><p>回到第一个问题，不妨在上面代码的基础上再加入一行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color); <span class="comment">//输出为空</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.defaultView.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>], <span class="literal">null</span>).color); <span class="comment">//或用getPropertyValue（"color"） 输出rgb(255, 0, 0)</span></span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"p"</span>).css(<span class="string">"color"</span>)); <span class="comment">//rgb(255, 0, 0)</span></span><br></pre></td></tr></table></figure><p>使用css()函数获取到的是rgb(255, 0, 0)，这证明了当<strong>获取样式值</strong>的时候，css()函数其实是和getComputedStyle()元素是一样的。由于getComputedStyle得到的样式值都是只读的，因此我们接下来只要验证一下当用css()函数设置样式值时，是否和element.style设置样式的作用一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color = green;</span><br><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>, <span class="string">"green"</span>)</span><br></pre></td></tr></table></figure><p>试验之后发现得到的结果都是一样的：<br><br><br><br><br><br><img src="/2018/02/02/Jquery-css/Jquery-css/jquery_css_1.png" alt="img"> <br></p><p>因此，两者在设置样式的效果都是一样的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Jquery.css()函数并不是与原生js的element.style一样的！Jquery.css()函数并不是与原生js的element.style一样的！Jquery.css()函数并不是与原生js的element.style一样的！（重要事情说三遍）</p><ul><li>获取样式时，css()函数与getComputedStyle()函数效果相同（不考虑伪类的情况下，css()函数无法获取伪类样式）</li><li>设置样式时，css()函数与element.style效果相同</li></ul><p>对于一个合格的前端程序员来说，还是要多啃啃书（比如《Javascript权威指南》、《Javascript高级编程》），好好学习一下js，不能只是一个只会用框架的人，“要学会做一个造轮子的人”</p><p><em>补充：既然说到了获取样式，其实在IE9以下的版本，IE只支持currentStyle来实现getComputedStyle的功能（但currentStyle获取不了伪类的样式），但由于currentStyle没有列入DOM标准，这里只说到了DOM标准的两种方法，而IE9已经支持DOM标准了。Jquery框架在前几个版本兼容了IE浏览器的几个较低的版本，而最新的版本已经进行IE低版本(IE6、IE7、IE8)的兼容性处理</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于一开始学习web前端，就去使用Jquery框架了，因此就导致自己对原生js的一些语法产生了误解，留下了很多坑，当自己抛弃Jquery，想用原生的js去写一个简单的网站时就出现了很多问题，其中在动态获取改变元素样式时就遇到了一个值得markdown的问题。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
</feed>
