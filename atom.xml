<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric_Blog</title>
  
  <subtitle>Eric&#39;s hexo_blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-07T03:08:46.792Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CORS</title>
    <link href="http://yoursite.com/2018/03/07/CORS/"/>
    <id>http://yoursite.com/2018/03/07/CORS/</id>
    <published>2018-03-07T02:04:29.000Z</published>
    <updated>2018-03-07T03:08:46.792Z</updated>
    
    <content type="html"><![CDATA[<p>CORS协议是解决跨域问题的方法之一，但自己作为前端开发者一直都没有深刻理解整个协议的作用，后来才发现，原来高版本的浏览器已经自己实现了CORS跨域，只需要服务器也遵从这种CORS协议，所以前端开发者不用自己编写额外的代码，看似和正常的ajax请求一样。但作为一个合格的工程师，不能只知其然而不知其所以然，因此要深究一下CORS协议的工作方式。</p><h2 id="CORS协议"><a href="#CORS协议" class="headerlink" title="CORS协议"></a>CORS协议</h2><blockquote><p>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><footer><strong>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</strong></footer></blockquote><p>CORS，即cross-origin-resource-share，跨域资源共享，是web为了解决常有的跨域问题而定的新的协议。在遵从CORS协议的浏览器中，发送的ajax请求会实现跨域功能，而相应的，遵从CORS协议的服务器则要配置相应的头部信息来允许浏览器跨域，接下来我们来分析一下它们是怎么工作的。</p><p>在这之前，我们需要区分两个概念：<code>简单请求</code>和<code>非简单请求</code></p><h3 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h3><p>只要同时满足以下两大条件，就属于<code>简单请求</code></p><ul><li><p>请求方法是以下三种</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li><p>HTTP的头信息不超出以下几种字段</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></li></ul><p>相反的，如果不满足这两个条件的请求即为<code>非简单请求</code></p><h2 id="简单请求工作原理"><a href="#简单请求工作原理" class="headerlink" title="简单请求工作原理"></a>简单请求工作原理</h2><p>对于一个简单请求，在浏览器向服务器发送ajax的时候，会带上一个<code>Origin</code>的首部字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面是一个请求的头部，其中<code>Origin</code>负责告诉服务器，这个请求来自哪个源（协议+域名+端口）。</p><p>接着，服务器返回的信息可能包含如下头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>其中，<code>Access-Control-Allow-Origin</code>则是用于确定哪些源是被允许的，是一个必须字段，它的取值可以是特定的域名，或者是<code>*</code>（代表任何源都可以），这里的值是<code>http://api.bob.com</code>，证明之前发送的请求的源是被允许的，因此则可以向该源返回正确的请求响应。</p><p><code>Access-Control-Allow-Credentials</code>是一个布尔值，表示是否允许发送<code>Cookie</code>，它是一个可选字段。默认情况下，<code>Cookie</code>不包括在CORS请求之中，跨域的时候不会带上cookie。但如果设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。</p><p><code>Access-Control-Expose-Headers</code>是一个可选值。在默认的CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>上面提到<code>Access-Control-Allow-Credentials</code>可以告诉浏览器允许发送cookie，但另一方面，浏览器的ajax请求也需要设置一个<code>withCredentials</code>，将它的值设为<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>还有，假设服务器需要获取到某个浏览器发来的cookie，这样它的<code>Access-Control-Allow-Origin</code>就不能设为<code>*</code>了，而是需要指定一个明确的值。</p><blockquote><p>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p><footer><strong>阮一峰的网络日志</strong><cite><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">www.ruanyifeng.com/blog/2016/04/cors.html</a></cite></footer></blockquote><h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求和简单请求最大的不同在于，它在发送正式的非简单请求之前，需要发送一个预检请求——preflight。预检请求的作用就是让浏览器先询问服务器，支持何种的头部信息和请求方式。</p><h3 id="preflight"><a href="#preflight" class="headerlink" title="preflight"></a>preflight</h3><p>对于以下的Javascript脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://api.alice.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>因为是PUT请求，因此是个非简单请求，所以会先发送一个Preflight请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>这是一个preflight请求的头部信息，可以看到preflight请求是以<code>OPTIONS</code>请求方法来请求的，与简单请求不同，非简单请求多出了两个首部字段，<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>。</p><p><code>Access-Control-Request-Method</code>用于告诉服务器，接下来的非简单请求时用何种请求方法请求的。</p><p><code>Access-Control-Request-Headers</code>用于告诉服务器，接下来的非简单请求有一个自定义的会额外发送的头信息字段</p><p>然后服务器收到这个preflight请求后，就会发出如下响应如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p><code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Credentials</code>和简单请求的意思一样。</p><p><code>Access-Control-Allow-Methods</code>表示的是服务器支持的请求方法，它是一个必需字段，可以看到它不只只指定了PUT，还有GET、POST，即它会一次性返回全部的支持方法，以免浏览器每次都发一个preflight来询问支持何种方法</p><p><code>Access-Control-Allow-Headers</code>表明服务器支持的所有头信息字段，它也是不限于浏览器在”预检”中请求的字段，也是一个必需字段。</p><p><code>Access-Control-Max-Age</code>表明的是这个preflight响应的过期时间，即在这个过期时间内，浏览器在发送非简单请求之前不用再发送preflight了，只需要遵循这个响应里面提到的支持的东西就可以了（比如支持的方法、头部）。</p><h3 id="正式请求和响应"><a href="#正式请求和响应" class="headerlink" title="正式请求和响应"></a>正式请求和响应</h3><p>得到了preflight响应后，浏览器检查返回的头部信息，各种<code>Access-Control-Allow-*</code>字段信息，假如都和自己要发送的非简单请求符合的话，则开始发送非简单请求，否则会触发<code>onerror</code>的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>可以看出来，非简单请求的头部信息和简单请求差不多，除了多了一个自定义头部，而这个自定义头部已经在preflight响应中被允许了。</p><p>然后服务器则返回一个请求响应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p><code>Access-Control-Allow-Origin</code>每个跨域响应都必须携带，其它就很简单了。</p><h2 id="与JSONP比较"><a href="#与JSONP比较" class="headerlink" title="与JSONP比较"></a>与JSONP比较</h2><p>JSONP是跨域中用得最多的技术，但是JSONP最大的缺点在于它只能发送GET请求。但是CORS支持所有的请求方式，不过JSONP可以向后兼容很多老式的浏览器，在不支持CORS协议的浏览器，也只能继续用JSONP来实现跨域了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a> —— MDN开发文档</li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a> —— 阮一峰网络日志</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CORS协议是解决跨域问题的方法之一，但自己作为前端开发者一直都没有深刻理解整个协议的作用，后来才发现，原来高版本的浏览器已经自己实现了CORS跨域，只需要服务器也遵从这种CORS协议，所以前端开发者不用自己编写额外的代码，看似和正常的ajax请求一样。但作为一个合格的工程
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>自己实现promise</title>
    <link href="http://yoursite.com/2018/02/27/promise%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/02/27/promise实现/</id>
    <published>2018-02-27T15:12:35.000Z</published>
    <updated>2018-03-05T06:06:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>promise是ES6引入的一个新的对象，目的就是为了让一串异步请求可以像同步事件一样链式执行。promise的意思就是我们所说的“承诺”，承诺就代表着当我某件某件事做好之后，你就需要做什么事，promise的承诺大致也是这样。今天面试遇到了一个问题，就是要自己实现一个promise，当时面试的时候并没有想出来，因此面试后查了资料理解了一下，并想mark下来</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第一个异步操作'</span>);</span><br><span class="line">        resolve(<span class="number">3</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'第二个异步操作'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(value); <span class="comment">//3</span></span><br><span class="line">            resolve(value * <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第三个异步操作'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(value);<span class="comment">// 6</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它的执行顺序是从上之下，依次是<code>第一个异步操作、第二个一步操作、3、第三个异步操作、6</code>，promise的原理就不多说了，主要是如何实现它。</p><h2 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h2><p>promise不是一个简单的东西，因此想要实现必须要一步一步来，先化繁为简，将最简陋的promise实现出来，然后在此基础上不断改善。</p><p>上面的例子有点复杂，因此我把它先简化为一个同步事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'第一个操作'</span>);</span><br><span class="line">      <span class="keyword">var</span> number=<span class="built_in">Math</span>.random();</span><br><span class="line">      <span class="keyword">if</span>(number &lt; <span class="number">0.5</span>)</span><br><span class="line">        resolve(<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        reject(<span class="string">"error"</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">//3</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);  <span class="comment">//error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个例子只有一个then，然后在创建promise对象的时候，有一半的几率调用resolve，一半几率调用reject。</p><h3 id="简易promise"><a href="#简易promise" class="headerlink" title="简易promise"></a>简易promise</h3><p>我们先解析一下整个Promise对象，首先就是它创建的时候，要传入一个函数，这个函数接受两个函数作为参数，这两个函数分别是resolve和reject，而且很明显这两个函数是在Promise内部定义的，因为外部并没有定义这两个函数。然后Promise对象还有一个then属性方法，它也接受两个函数，可以发现，其实这两个函数和之前说的resolve和reject有着密切的关系，那就是resolve和reject本质上就是then传入的这两个函数，然后根据这几个点，先创建一个简易的Promise对象</p><figure class="highlight javascript"><figcaption><span>https://hexo.io/zh-cn/docs/tag-plugins.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value;</span><br><span class="line">  <span class="keyword">this</span>.resolveFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.rejectFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value=val;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.resolveFunc(self.value);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self=<span class="keyword">this</span>;</span><br><span class="line">  self.value=val;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.rejectFunc(self.value);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolveFunc, rejectFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resolveFunc = resolveFunc;</span><br><span class="line">  <span class="keyword">this</span>.rejectFunc = rejectFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个MyPromise的对象，每个对象实例拥有自己独有的value、resovleFunc、rejectFunc，这里的resolveFunc和rejectFunc其实就是我们之前提到的resolve和reject方法，但在这里，我们把reject和resolve放到原型里面定义，这样起到函数共享的作用，节省资源，然后在函数里面，就用this获取实例本身的resolveFunc和rejectFunc。</p><p>在代码中比较关键的地方就是，resolve和reject有一个setTimeout函数，因为我们需要知道当我们new Promise()新建一个promise实例的时候，resolveFunc和rejectFunc是还没定义的，因为这两个方法应该是要在调用then后才传入的，所以我们等then同步调用完后才执行。</p><h3 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h3><p>我们都知道promise有三个状态：pending、resolved、rejected，而且一旦进入resolved或者rejected状态，就不能变成其它状态了，在我们上面的例子中，由于我们没有引入状态，因此可能会出现一种情况，就是resolve回调和reject回调都执行了。</p><p>因此我们要记录这3个状态</p><figure class="highlight javascript"><figcaption><span>https://hexo.io/zh-cn/docs/tag-plugins.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value;</span><br><span class="line">  <span class="keyword">this</span>.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">this</span>.resolveFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.rejectFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'resolved'</span>;</span><br><span class="line">    self.value=val;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.resolveFunc(self.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self=<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'rejected'</span>;</span><br><span class="line">    self.value=val;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.rejectFunc(self.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolveFunc, rejectFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resolveFunc = resolveFunc;</span><br><span class="line">  <span class="keyword">this</span>.rejectFunc = rejectFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，promise对象就会根据当前的状态来选择执行resolve和reject中的回调函数</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>接着就是promise比较核心的地方了，就是要实现一个链式调用，想到要链式调用那自然而然会想到，每次then方法后都要返回一个Promise对象</p><p>因此我们修改一下then方法：</p><figure class="highlight javascript"><figcaption><span>https://hexo.io/zh-cn/docs/tag-plugins.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolveFunc, rejectFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve_next, reject_next</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveFuncWrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = resolveFunc(self.value);</span><br><span class="line">      resolve_next(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejectFuncWrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = rejectFunc(self.value);</span><br><span class="line">      resolve_next(result);</span><br><span class="line">    &#125;</span><br><span class="line">    self.resolveFunc = resolveFuncWrap;</span><br><span class="line">    self.rejectFunc = rejectFuncWrap;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解这里的代码，就必须要理解闭包。我们可以先不仔细看return new Promise中的代码，我们只需要知道then方法的目标和之前一样，首先就是为实例中的resolveFunc和rejectFunc赋值，然后一个新的目标就是返回Promise实例。</p><blockquote><p>这里以上面一个例子来说明。在上面的链式调用例子中，出现了两个Promise，第一个是我们通过new Promise显式定义的，我们叫它Promise 1,而第二个Promise，是Promise 1的then方法返回的一个新的，我们叫它Promise 2 。在Promise 1的resolve方法执行之后，resolve的返回值，会传递给Promise 2的resolve作为参数，这也是为什么上面第二个then中打印出了第一个then返回的字符串。</p><p>而我们封装的目的，就是为了让Promise 1的resolve或者reject在执行后，将其返回值传递给Promise 2的resolve。在我们自己的实现中，Promise 2的resolve我们命名为resolve_next，在Promise 1的resolveFunc执行之后，我们拿到返回值result，然后调用resolve_next(result)，传递参数给Promise 2的resolve。这里值得注意的是，无论Promise 1执行的是resolveFunc还是rejectFunc，其之后调用的，都是Promise 2的resolve</p><footer><strong>https://hexo.io/zh-cn/docs/tag-plugins.html</strong></footer></blockquote><p>这样实现后，还差一点，就是假如在then中传入的resolve和reject函数return的不是基本类型的数，而是一个return一个promise对象，那就要再更新then方法的代码，我们要判断<code>resolveFunc(self.value)</code>回来的值是否为Promise的实例</p><figure class="highlight javascript"><figcaption><span>https://hexo.io/zh-cn/docs/tag-plugins.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolveFunc, rejectFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve_next, reject_next</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveFuncWrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = resolveFunc(self.value);</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">//如果result是MyPromise对象，则通过then将resolve_next和reject_next传给它</span></span><br><span class="line">        result.then(resolve_next, reject_next);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果result是其他对象，则作为参数传给resolve_next</span></span><br><span class="line">        resolve_next(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejectFuncWrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = rejectFunc(self.value);</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">//如果result是MyPromise对象，则通过then将resolve_next和reject_next传给它</span></span><br><span class="line">        result.then(resolve_next, reject_next);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果result是其他对象，则作为参数传给resolve_next</span></span><br><span class="line">        resolve_next(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self.resolveFunc = resolveFuncWrap;</span><br><span class="line">    self.rejectFunc = rejectFuncWrap;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的promise对象就实现完了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hexo.io/zh-cn/docs/tag-plugins.html——大牛博客" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins.html——大牛博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;promise是ES6引入的一个新的对象，目的就是为了让一串异步请求可以像同步事件一样链式执行。promise的意思就是我们所说的“承诺”，承诺就代表着当我某件某件事做好之后，你就需要做什么事，promise的承诺大致也是这样。今天面试遇到了一个问题，就是要自己实现一个pr
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序解析html</title>
    <link href="http://yoursite.com/2018/01/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90html/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90html/"/>
    <id>http://yoursite.com/2018/01/08/微信小程序解析html/微信小程序解析html/</id>
    <published>2018-01-08T15:08:46.000Z</published>
    <updated>2018-02-14T12:11:07.794Z</updated>
    
    <content type="html"><![CDATA[<p>近日，由于在小程序的开发过程中遇到了解析html标签的问题，发现微信小程序不仅不能自动解析html标签，而且还不能解析动态加载文本中的view标签，于是上网查了许多资料，自己也想了一点办法来解决</p><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>最近在做小程序的一个搜索功能（其实是非常low的搜索），输入一个字段后服务器根据这个字段来进行匹配搜索，然后返回相应的数据，并且在匹配的字段中高亮显示，而这种高亮显示使用了html标签来对字段包含，具体形式如下：（当我在搜索框输入“鲜”来搜索用户时，服务端返回的字段如下）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"nickname"</span> : <span class="string">"&lt;font color=#29abe2&gt;鲜&lt;/font&gt;橙2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(虽然font标签和color属性已经是被人唾弃和淘汰的，但是因为是后端工程师返回的字段和写的协议，所以我们也只能遵循)</em><br></p><p>假如我们直接使用<code></code>绑定该数据在wxml中显示时，微信小程序不会解析该Html标签，而是直接将它当成字符串的形式输出了，效果如下:<br><br><img src="https://i.loli.net/2018/02/14/5a841f6f2a2b8.png" width="400px"><br><br></p><p>因此不能指望小程序自动帮我们解析html标签，要自己想想办法（虽然color中的属性值没用引号’’括起来，但经过试验即使括起来也依然解析不了）</p><h2 id="WxParse"><a href="#WxParse" class="headerlink" title="WxParse"></a>WxParse</h2><p>WxParse是某位前端大牛写的一个插件，详情可以看一下其<a href="https://github.com/icindy/wxParse" target="_blank" rel="noopener">github地址</a>，主要实现是根据正则表达式将各个html标签（包括图片）转成适当的缩进、换行等等</p><blockquote><p>但是，由于如果要使用该插件，要下载其js和wxss等文件，而且工程量不小，自己特别懒，不想为了实现该功能而导入该插件，而且小程序还有代码包的大小限制，因此最终没有使用WxParse。</p></blockquote><h2 id="rich-text"><a href="#rich-text" class="headerlink" title="rich-text"></a>rich-text</h2><blockquote><p>由于不想用网上大牛们写的插件，那么就要自己琢磨一个骚方法出来，因此自己又在小程序的开发文档中再细细地看了目录，发现了一个rich-text富文本编辑组件，顿时就有了灵感</p></blockquote><h3 id="rich-text用法"><a href="#rich-text用法" class="headerlink" title="rich-text用法"></a>rich-text用法</h3><p>rich-text的用法并没有想象中的那么方便暴力，并不是直接在标签之中嵌入html代码，小程序就会帮你自动解析，而是根据其nodes属性值来插入数据，标签之间是不用写数据的，看下<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/rich-text.html" target="_blank" rel="noopener">官方文档</a>的使用说明：<br></p><p><img src="https://i.loli.net/2018/02/14/5a841f700556e.png" width="100%"><br></p><p><img src="https://i.loli.net/2018/02/14/5a841f70b253d.png" width="100%"><br></p><p>乍一看好像挺复杂的，总结一下<strong>其实就是在nodes属性中用数组的形式定义一颗DOM节点树</strong>，并且文本必须由text文本节点包住，考虑一下一开始服务器返回的字段，我们可以将它补全text标签（text表示文本节点），然后对照着想象出DOM树：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DOM结构：</p><ul><li>font<ul><li>text（鲜）</li></ul></li><li>text（橙2）</li></ul><p>根据这个结构，我们可以对照着写进nodes属性，rich-text组件就会解析这个nodes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nodes: [&#123;</span><br><span class="line">    type: <span class="string">'node'</span>,</span><br><span class="line">    name: <span class="string">'font'</span>,</span><br><span class="line">    attrs: &#123; <span class="attr">style</span>: <span class="string">'color: #29abe2'</span> &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: <span class="string">'鲜'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: <span class="string">'橙2'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是，这样还是会遇到问题（虽然这不是rich-text的错，因为本来font标签就不太推荐用了）：</p><ol><li>rich-text组件识别不了已经被淘汰的font节点</li><li>rich-text不能那么智能地将color属性写成style样式</li></ol><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>既然rich-text不能识别这个标签，那我们可以在写进rich-text之前，将这个标签替换成其它的标签，由于font是行内元素，因此我们可用用a、span这两个常用的行内元素来替换掉它，这里我就是用a。并且在替换的过程中我们可以使用style将原本font中的属性放进style中（由于服务器返回的是固定的标签和属性，因此我们也固定style为color:#29abe2即可）。那怎么替换<font>标签呢，自然就是使用<a href="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式</a></font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replaceHTML: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;font[\w#= ]*&gt;/gi</span>, <span class="string">"&lt;a class='search_selected'&gt;"</span>) <span class="comment">//替换&lt;font color=29abe2&gt;标签</span></span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;\/font&gt;/gi</span>, <span class="string">"&lt;/a&gt;"</span>) <span class="comment">//替换&lt;/font&gt;标签</span></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码中我没有直接用style，而是定义了一个叫search_selected的class，下面会讲到怎么使用该class</p><h2 id="问题还没解决"><a href="#问题还没解决" class="headerlink" title="问题还没解决"></a>问题还没解决</h2><blockquote><p>做了上面那么多步，其实问题还没解决，因为你会发现，我们上面一直都是使用静态数据，但我们搜索得到的结果肯定是动态的，每次的结果都是不同的，不会一直都为<code>&lt;font color=#29abe2&gt;鲜&lt;/font&gt;橙2</code>，因此我们需要动态地识别返回来的字符串，然后动态地为rich-text组件生成nodes属性值</p></blockquote><p>在讲整体思路之前，我们要先抛弃掉上面写的replaceHTML函数，那个函数只是为了展示如何替换<font>标签而已，但我们可以利用上面写过的正则表达式来帮助我们搜索<font>标签的位置。</font></font></p><p>解决的整体思路：</p><ol><li>搜索服务器返回的字符串中的<code>&lt;font&gt;</code>标签的位置</li><li>将该位置的索引记录下来，在该位置之前的子字符串即为文本节点，用用text包住push进nodes属性中，然后将该位置的<code>&lt;font&gt;</code>标签成空字符串””</li><li>搜索服务器返回的字符串中的<code>&lt;/font&gt;</code>标签的位置</li><li>在之前记录的<code>&lt;font&gt;</code>标签的位置和<code>&lt;/font&gt;</code>标签位置之间的就是元素节点，即要高亮的部分，这个部分用我们刚才的思想，我们用<code>&lt;a class=&#39;search_selected&#39;&gt;&lt;text&gt;&lt;/text&gt;&lt;/a&gt;</code>元素将该部分包住，然后Push进nodes属性中</li><li>将<code>&lt;/font&gt;</code>标签替换成空字符串’’，在<code>&lt;/font&gt;</code>标签之后子字符串即为文本节点，用用text包住push进nodes属性中</li><li>然后重复以上步骤</li></ol><p>说的非常非常生涩累赘，我们用例子来说明就恍然大悟了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>用我们整体思想，先找到<code>&lt;font&gt;</code>标签，记录其位置，然后它前面的子字符串用<code>&lt;text&gt;</code>包住，由于这里的<code>&lt;font&gt;</code>之前没有子字符串，因此这里跳过。</p><p>然后将<code>&lt;font&gt;</code>标签替换成空字符串:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>找到<code>&lt;/font&gt;</code>标签，根据之前记录的<code>&lt;font&gt;</code>的位置，可以确定它们包围的子字符串为”鲜”，然后用<code>&lt;a class=&#39;search_selected&#39;&gt;&lt;text&lt;/text&gt;&lt;/a&gt;</code>包住该字符串，并且将<code>&lt;/font&gt;</code>标签替换成空字符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'search_selected'</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>橙2</span><br></pre></td></tr></table></figure><p>之后再把<code>&lt;/font&gt;</code>标签后的字符串用text包围起来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'search_selected'</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于已没有<code>&lt;font&gt;</code>标签了，则不用继续重复了，根据最后得到的这个形式，nodes属性得到的值就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nodes: [&#123;</span><br><span class="line">    type: <span class="string">'node'</span>,</span><br><span class="line">    name: <span class="string">'a'</span>,</span><br><span class="line">    attrs: &#123; <span class="attr">class</span>: <span class="string">'search_selected'</span> &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: <span class="string">'鲜'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: <span class="string">'橙2'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果觉得上面的例子不够生动的话，可以再看这个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 变化前 --&gt;</span></span><br><span class="line">大<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">font</span>&gt;</span>2<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#29abe2</span>&gt;</span>橙<span class="tag">&lt;/<span class="name">font</span>&gt;</span>2</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 变化后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>大<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>  <span class="attr">class:</span> '<span class="attr">search_selected</span>'&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>鲜<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>2<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>  <span class="attr">class:</span> '<span class="attr">search_selected</span>'&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>橙<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>2<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后就是JS实现了，其实就十多行的代码，并不复杂，看注释应该就懂了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">replaceHTML: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodes = [], begin_index = <span class="number">-1</span>, end_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (str.search(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>) != <span class="number">-1</span>) &#123; <span class="comment">//如果存在&lt;font&gt;标签则继续循环</span></span><br><span class="line">    begin_index = str.search(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>); <span class="comment">//记录下&lt;font&gt;的位置</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;font[\w#= ]*&gt;/</span>, <span class="string">""</span>); <span class="comment">//替换&lt;font&gt;为空字符串</span></span><br><span class="line"></span><br><span class="line">    nodes.push(&#123; <span class="comment">//这一步是将&lt;/font&gt;和&lt;font&gt;之间或第一个&lt;font&gt;之前的字符串推入nodes数组中</span></span><br><span class="line">      type: <span class="string">'text'</span>,</span><br><span class="line">      text: str.substring(end_index == <span class="number">-1</span> ? <span class="number">0</span> : end_index, begin_index)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    end_index = str.search(<span class="regexp">/&lt;\/font&gt;/</span>); <span class="comment">//记录下&lt;/font&gt;的位置</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;\/font&gt;/</span>, <span class="string">""</span>); <span class="comment">//替换&lt;/font&gt;为空字符串</span></span><br><span class="line">    nodes.push(&#123; <span class="comment">//这一步是将&lt;font&gt;和&lt;/font&gt;之间的元素节点推入nodes</span></span><br><span class="line">      name: <span class="string">'a'</span>,</span><br><span class="line">      attrs: &#123; <span class="attr">class</span>: <span class="string">'search_selected'</span> &#125;, <span class="comment">//这里的class会从wxss文件中定义的同名class中寻找样式</span></span><br><span class="line">      children: [&#123;</span><br><span class="line">        type: <span class="string">'text'</span>,</span><br><span class="line">        text: str.substring(begin_index, end_index)</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodes.push(&#123; <span class="comment">//while循环结束后，假如最后一个&lt;/font&gt;标签后还有字符，则将它推入nodes数组中</span></span><br><span class="line">    type: <span class="string">'text'</span>,</span><br><span class="line">    text: str.substring(end_index, str.length)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>重写replaceHTML后，将rich-text中的nodes属性值绑定我们函数放回的nodes值，rich-text帮我们解析了<code>&lt;a&gt;</code>标签并生成了我们想要的结果<br></p><p><img src="https://i.loli.net/2018/02/14/5a841f70e65e5.png" width="400px"><br></p><p>我们可以看到由原本服务器返回的字符串和相应得到的nodes数组<br></p><p><img src="https://i.loli.net/2018/02/14/5a841f71d207c.png" width="400px"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写的太啰嗦，其中可能也有很多饶了弯的地方，但总体的意思就是替换<code>&lt;font&gt;</code>为<code>&lt;a&gt;</code>标签，然后脑补出一个DOM树将它推入nodes数组，利用rich-text组件将其显示出来。其中如何动态生成整个Nodes数组，或者整个nodes数组中的形式也有很多种，最终能显示出想要的结果就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日，由于在小程序的开发过程中遇到了解析html标签的问题，发现微信小程序不仅不能自动解析html标签，而且还不能解析动态加载文本中的view标签，于是上网查了许多资料，自己也想了一点办法来解决&lt;/p&gt;
&lt;h2 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="http://yoursite.com/2018/01/08/BFC/"/>
    <id>http://yoursite.com/2018/01/08/BFC/</id>
    <published>2018-01-08T00:14:45.000Z</published>
    <updated>2018-03-08T01:15:26.230Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p></blockquote><p>BFC是一个我们经常用到或碰到，但没有真正深入理解的一个概念，因此需要markdown一下。</p><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>block指的就是块级的意思，我们都知道在css中，各个元素在页面中的布局都是用盒子模型来定义的，盒子模型一般分为三种：</p><ul><li><p>block-level box:</p><p>display 属性为 block, list-item, table 的元素，会生成 block-level box。</p></li><li><p>inline-level box:</p><p>display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。</p></li><li><p>run-in box</p></li></ul><h2 id="formatting-context"><a href="#formatting-context" class="headerlink" title="formatting context"></a>formatting context</h2><blockquote><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p></blockquote><h2 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h2><p>了解了BFC是什么以后，就要了解一下BFC的布局规则和它的特点。</p><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ol><p>我们下面会看到，第2、4、6这三个是我们经常遇到的情况。</p><h2 id="BFC的生成"><a href="#BFC的生成" class="headerlink" title="BFC的生成"></a>BFC的生成</h2><p>BFC并不是任何block布局的元素都会生成的，相反，仅仅是<code>display: block</code>并不会生成BFC。我们来看下哪些元素才能产生BFC环境？</p><ul><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ul><p>可见，非常关键的一点，<code>display: block</code>没有出现在里面！！</p><h2 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h2><p>BFC的作用很常见，我们经常会用到，只是我们不知道它真正的原理是BFC而已。</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border: 2px solid black"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"float:left; width: 100px; height: 100px; border: 2px solid grey"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上的代码就是会导致内层的浮动子元素会溢出父元素，而不是撑开父元素的高度，父元素的高度依然会为0。为了让清除浮动，将父元素重新包住浮动元素，除了设置一个<code>clearfix</code>的伪元素或者新加一个子元素以外，还可以指定父元素<code>overflow: hidden</code>。</p><p>这个原理就是利用了BFC。注意BFC规则的第六点：<code>计算BFC的高度时，浮动元素也参与计算</code>，将父元素设为<code>overflow: hidden</code>之后，父元素就会形成一个BFC，这样在计算它的高度的时候，它内部的浮动元素也参与计算，因此父元素就必须包住这个浮动元素。</p><h3 id="自适应的两栏布局"><a href="#自适应的两栏布局" class="headerlink" title="自适应的两栏布局"></a>自适应的两栏布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .aside &#123;</span></span><br><span class="line"><span class="undefined">    float: left;</span></span><br><span class="line"><span class="undefined">    width: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  .main &#123;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现两栏布局的时候，侧边栏需要浮动到左边，如果按以上代码编写后，可以发现它们的背景色会重叠。这时候我们一般会对主栏使用<code>margin-left: 200px</code>来让避开侧栏。但是这样就变得必须要提前确定和知道侧栏的宽度，其实还有一种更方便的方法，就是主栏设为<code>overflow: hidden</code>。</p><p>其原理就是BFC作用规则的第四点：BFC的区域不会与float box重叠。将主栏设为<code>overflow: hidden</code>之后，主栏就形成了BFC上下文环境，这样它就不能与浮动的侧栏重叠，因此就会自动的避开侧栏，而不用自己去写<code>margin-left</code></p><h3 id="解决垂直margin重叠"><a href="#解决垂直margin重叠" class="headerlink" title="解决垂直margin重叠"></a>解决垂直margin重叠</h3><p>我们都知道在css布局过程中垂直的margin会重叠并取最大者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  div.container &#123;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  div.main &#123;</span></span><br><span class="line"><span class="undefined">    width: 500px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    margin: 20px 0px;</span></span><br><span class="line"><span class="undefined">    background-color: black;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照这样的布局，上下两个main的div的间隔为20px，这是因为它们都处于外层div的BFC内，这就是BFC规则的第二条所说的<code>属于同一个BFC的两个相邻Box的margin会发生重叠</code>，因此它们的上下margin重叠了。</p><p>假如我们要让它们的间隔变成40px，则就是将它们变成两个独立的BFC。如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  div.container &#123;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  div.main &#123;</span></span><br><span class="line"><span class="undefined">    width: 500px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    margin: 20px 0px;</span></span><br><span class="line"><span class="undefined">    background-color: black;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BFC是块级格式上下文的意思，它其中有六个重要的规则，核心的思想就是BFC的布局不受外部的影响，也不影响外部的布局，即形成一个封闭的上下文。BFC是我们常用的一个上下文规则，我们不仅要会用这些布局，也要知道其中蕴含的BFC的原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.zyy1217.com/2016/12/15/BFC%E7%A5%9E%E5%A5%87%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">http://www.zyy1217.com/2016/12/15/BFC%E7%A5%9E%E5%A5%87%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86/</a></li><li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25321647</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout和setInterval的坑</title>
    <link href="http://yoursite.com/2017/12/28/setTimeout/"/>
    <id>http://yoursite.com/2017/12/28/setTimeout/</id>
    <published>2017-12-28T14:19:49.000Z</published>
    <updated>2018-02-18T15:45:51.949Z</updated>
    
    <content type="html"><![CDATA[<p>setTimeout和setInterval是两个js中常用的函数，使用方法很简单，文档介绍得也不难（简陋），但是在实际运用的过程中经常会引发一些bug，所以有必要深究一下这两个函数的作用</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"dosomething"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>非常简单的用法，就是超时调用一个匿名函数，第二个参数就是指定延迟的时间。表面上的意思就是，过1000ms之后执行<code>console.log(&quot;dosomething&quot;)</code>，但是实际上在Javascript的代码运行时，并不代表是过1000ms就执行匿名函数。</p><h3 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h3><blockquote><p>关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。</p><footer><strong>Nicholas C.Zakas</strong><cite>Javascript高级程序设计</cite></footer></blockquote><p>《Javascript高级程序设计》书中有提及到，setTimeout的延迟效果和大部分人意想的效果并不同。<strong>由于Javascript是一个单线程的运行环境，因此所有要执行的代码都放到了一个队列里面</strong>，这个队列也是上述引用说到的队列，我们用代码和图来加以说明。</p><p>考虑以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125;, <span class="number">250</span>);</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，为一个btn元素加入一个onclick的响应函数，在函数中有一部是调用setTimeout延时调用一个匿名函数，当程序在执行setTimeout的时候，它会按照setTimeout的第二个参数定义的时间，在250ms过后将匿名函数放到队列的末尾（<strong>并不一定是250ms后立即执行</strong>），假设btn的onclick函数还有其它的代码要执行，onclick函数的执行时间一共为300ms，那么如下图所示：</p><p><img src="https://i.loli.net/2018/02/18/5a8991c060d3c.png" width="600px"></p><p>若0ms的时候，onclick响应函数被触发执行，然后在5ms的时候，程序执行到setTimeout语句时，它便创建一个定时器，然后在255ms的时候将定时器中的匿名函数的代码添加到队列中，由于此时队列中onclick的响应函数仍未执行完毕，因此setTimeout匿名函数的代码要等到300ms后，onclick执行完毕后才能执行。</p><blockquote><p>从这个例子看出来，setTimeout的作用只是延迟一段时间，将匿名函数添加到队列中，并不是我们理所当然的以为就是简单的过一段时间后马上调用执行该代码。而且，如果onclick函数的执行时间更长，或者在添加定时器代码到队列之前，队列中又被添加了其它需要执行的代码，那么定时器代码的真正执行时间要比设定的250ms长得多，因此这就是调用setTimeout函数引起许多时间上的误差的原因<em>（不过换句说，如果当队列处于完全空闲的状态时，setTimeout函数和我们预想的效果是一样的，就是当定时器代码一被添加到队列时，就被马上执行）</em></p></blockquote><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>一样直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"dosomething"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>用起来和setTimeout函数差不多，只不过setInterval是一个循环调用，表面上达到的效果就是每过1000ms执行一次匿名函数中的<code>console.log(&quot;dosomething&quot;)</code>，但实际上setInterval会比setTimeout更坑，这也是为什么大牛们都推荐用setTimeout来代替setInterval</p><h3 id="setInterval的坑"><a href="#setInterval的坑" class="headerlink" title="setInterval的坑"></a>setInterval的坑</h3><p>假设以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  func(i++);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>如果setInterval匿名函数的执行时间少于100并且执行队列空闲的话，那么一切风平浪静，和预想的效果一样</p><p><img src="https://i.loli.net/2018/02/18/5a8996d105a88.png" width="600px"></p><p>假如匿名函数的时间稍微比100ms大了一点，那么将会造成循环调用的代码需要等待上一次的代码执行完才执行</p><p><img src="https://i.loli.net/2018/02/18/5a899801906f6.png" width="600px"></p><p>可以发现，以上这种情况会导致预想的每100ms执行一次的效果被破坏，实际效果会超过100ms后才会执行第二遍的代码。然而这不是最糟糕的，假如匿名函数中的代码执行时间更长，而在执行的过程中又要创建多个新的等待执行的匿名函数会发生什么情况？</p><blockquote><p>当调用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。</p><footer><strong>Nicholas C.Zakas</strong><cite>Javascript高级程序设计</cite></footer></blockquote><p>这句话的意思是什么呢？我们继续用上面的代码例子来说明，假设第一次调用setInterval创建的匿名函数执行超过了400ms，而在这400ms过程中理应继续创建新的func，但实际上并没有：</p><p><img src="https://i.loli.net/2018/02/18/5a8999c40bcb9.png" width="600px"></p><p>在图示中，在300ms和400ms中有一个垃圾桶的图标，这代表的是在300ms和400ms中被创建的理应被添加到队列中的func函数被丢弃了。这和《Javascript高级程序设计》书中的说法是一致的，我们可以这样理解：<strong>在300ms时，100ms创建的func(1)仍在执行，而200ms创建的func(2)正在队列中等待，由于队列中有一个完整实例func(2)在等待，因此300ms创建的func函数就被丢弃了。到了400ms的时候，情况是相同的。而到了500ms的时候，假设func(1)执行完了，func(2)正在执行，那么500ms创建的func函数就不会被丢弃掉，而是会添加到队列中。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述的代码执行结果我们可以发现，setTimeout函数和setInterval函数都存在一个共同的问题，就是<strong>它们无法保证严格按照传入的第二个参数（延迟时间）来延迟执行</strong>，而且setInterval函数还有一个更可怕的问题就是：<strong>它可能还会丢失一些原本理应按循环执行的函数</strong>，这也是为什么有时候很多动画效果都会用setTimeout代替setInterval去做的原因，即使setTimeout也不一定精确。</p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>正是因为setTimeout和setInterval无法保证执行的时间，所以一个可以保证执行时间的requestAnimationFrame呼之欲出。这个函数基本上就是为了js实现动画而生的，它可以保证函数以60Hz（因为这个是浏览器重绘刷新的极限）的频率进行刷新，但requestAnimationFrame并不是一个完全替代setTimeout和setInterval的函数，因为它无法自己调整函数执行的间隔（延迟）时间，它只能按照浏览器定义的每秒60次的频率去计算间隔时间。</p><p>其基本用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  element.style.left = <span class="built_in">Math</span>.min(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">'px'</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure><blockquote><p>这是选自moz的MDN文档的写法，当然最好还是选用一些兼容性的写法（加入前缀），而且并不是所有版本的浏览器都会返回timestamp的参数（虽然这个参数也没什么用，只是用来返回一个浏览器上一次重绘的时间戳）</p></blockquote><p>requestAnimationFrame的用法看起来其实和setTimeout差不多，只不过requestAnimationFrame需要自己定义一个结束或开始的条件，否则它会一直调用下去。</p><p>因此，setTimeout和setInterval在自定义延迟调用的时候是非常有用的，只不过需要我们弄清楚它的坑而已，而当需要做出一个平稳追求完美的动画时，可以使用requestAnimationFrame来帮助我们，而不再依赖setTimeout函数。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Javascript高级程序设计》</li><li><a href="http://qingbob.com/difference-between-settimeout-setinterval/" target="_blank" rel="noopener">http://qingbob.com/difference-between-settimeout-setinterval/</a> (感谢这位大牛，很多图都选自这里)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;setTimeout和setInterval是两个js中常用的函数，使用方法很简单，文档介绍得也不难（简陋），但是在实际运用的过程中经常会引发一些bug，所以有必要深究一下这两个函数的作用&lt;/p&gt;
&lt;h2 id=&quot;setTimeout&quot;&gt;&lt;a href=&quot;#setTimeo
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>react受控组件和不受控组件</title>
    <link href="http://yoursite.com/2017/12/21/react%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E4%B8%8D%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/12/21/react受控组件和不受控组件/</id>
    <published>2017-12-21T15:35:53.000Z</published>
    <updated>2018-02-22T07:31:15.516Z</updated>
    
    <content type="html"><![CDATA[<p>学习过react的人都知道，react中有两个概念——受控组件和不受控组件，这两个组件大部分是值表单控件，受控和不受控最大的区别在一个属性——value，在入坑react的时候，一开始很容易被这个value属性坑掉，因为它和我们之前学过的html元素中的value属性不太相同</p><h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><blockquote><p>我们可以通过使 React 的 state 成为 “单一数据源原则” 来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。</p><footer><strong>http://www.css88.com/react/docs/forms.html</strong></footer></blockquote><p>从官方文档中摘录的概念，浓缩一下这句话，可以理解中在组件中所有可变的值都用state来控制，则该组件就是受控组件</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>我们通过表单中的input元素来举例说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//忽略构造函数等其它函数，只列举事件响应函数，和其对应的控件</span></span><br><span class="line">handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码的意思就是在input输入框中每当内容有变化时，就用<code>event.target.value</code>来更新value值，看似很简单，但其实疑惑重重</p><ul><li>原本我们学习的html中，表单中value的值不是会自动改变的吗？</li><li>input的value属性不是自动和<code>event.target.value</code>相等的吗？</li></ul><p>为了解决我的疑惑，因此我就开始敲代码验证了一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">    <span class="comment">// this.setState(&#123;value: event.target.value&#125;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"123"</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>我将handleChange中的代码注释掉，并且将value初始化为123，按照我们以往对input元素的理解，value属性是一个输入框的初始默认值，当我们输入修改它后，value会自动跟着改变。</p><p>但是，当代码运行后，你会发现在输入框中无论你怎么在其中输入新的字符或者删除字符，输入框中依然显示为“123”，这证明在react中指定input的value值之后，如果不是一个可变的state值，如指定一个固定的如”123”这样的值，那么这个value值就一直不会改变，这也是可控组件的名称由来，证明这个value值已经被你牢牢控制住了。</p><h3 id="value和event-target-value"><a href="#value和event-target-value" class="headerlink" title="value和event.target.value"></a>value和event.target.value</h3><p>上面还提到了一个问题，就是value和<code>event.target.value</code>的关系是怎么样的，它们为什么不是一直相等的？</p><p>在回答这个问题之前，我们需要知道<code>event.target</code>指的是哪个元素，而这里需要引入一个虚拟DOM的概念</p><blockquote><p>虚拟DOM是react中的一个精髓所在，主要是用在diff算法中，在更新视图时用的，我们用react的render函数构建出来的组件都是放在虚拟DOM中</p></blockquote><p>结合一下图片来了解一下虚拟DOM的作用</p><p><img src="https://i.loli.net/2018/02/22/5a8e5bf6ded2a.jpg" alt="虚拟DOM"></p><p>我们可以根据图片大致理解一下，我们render函数返回的input元素是属于虚拟DOM中的，而其中的value属性是虚拟DOM中input元素的属性，因此它并不等同于底层真实DOM中的input元素的value属性。因此，我们可以这样理解：<strong>定义在虚拟DOM的元素和属性会被转化到底层真实的DOM中，但是不一定是同一个东西</strong></p><p>然后，我们回到一开始的问题中，<code>event.target</code>指向的应该是底层的DOM中的input元素，因为我们可以从图中看到，事件的响应是从底层的DOM传到虚拟DOM再传到App的，此时虚拟DOM的value值为“123”，而底层input元素的value值就是我们以前理解的输入的值，所以此时两者的值不相同</p><p>接下来又有了一个新问题，就是如果两者的值不相同时，那么会发生什么？假如表单被提交，提交的是哪个值？</p><p>我们加上nodeJS的代码来测试了一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSX</span></span><br><span class="line">handleChange(event) &#123;</span><br><span class="line">    <span class="comment">// this.setState(&#123;value: event.target.value&#125;);</span></span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form method=<span class="string">"GET"</span> action=<span class="string">"http://localhost:8888/hello"</span>&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> value=<span class="string">"123"</span> name=<span class="string">"name"</span> onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">           &lt;input type=<span class="string">"submit"</span> value=<span class="string">"submit"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/node.js</span></span><br><span class="line"><span class="regexp">app.get("/</span>hello<span class="string">", function(req, res) &#123;</span></span><br><span class="line"><span class="string">console.log("</span>--hello request--<span class="string">");</span></span><br><span class="line"><span class="string">console.log("</span>name: <span class="string">" + req.query.name);</span></span><br><span class="line"><span class="string">res.send("</span>success<span class="string">");</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p><code>handleChange</code>还是什么都不做，而表单向nodejs服务器发送了一个GET请求，当我们想input输入框疯狂打字后，和之前一样，输入框一直显示“123”不会被修改，按下提交键后，在nodejs后台收到的name值仍是“123”。这里先不急着下结论，我又试着在handleChange中加一个输出代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果出现了一个现象：</p><p><img src="https://i.loli.net/2018/02/22/5a8e61d9cf880.png" alt="input"></p><p>输入框显示的一直是“123”，我在“123”之后依次按下键盘1、2、3、4、5、6，发现输出的值并不是“1231”<br>、“12312”、“123123”……，而是每一次都只有4个数字，就是“123”加上我输入的数字。</p><p>结合这两个测试，我大致有了这样的理解：底层DOM的改变会触发事件处理函数并冒泡至虚拟DOM，然后虚拟DOM的处理函数就会进行处理，其中传入的参数<code>event</code>是我们平时熟悉的事件处理函数传入的<code>event</code>参数，<code>event.target</code>也是指触发事件的底层DOM的html元素。当每次处理完触发的事件后，虚拟DOM会再更新底层的DOM。</p><p>这就是说，在上面的例子中，假如<code>handleChange()</code>函数利用<code>setState</code>更新了虚拟DOM中input的value值之后，处理完后，底层DOM中input的value值也会相应地被更新为虚拟DOM中input的value值</p><p><img src="https://i.loli.net/2018/02/22/5a8e68bad4582.jpg" alt="setState"></p><p>这时，底层的value和虚拟DOM的value都是输入的值，都是“1231”，但是如果handleChange不改变虚拟DOM中的value值，那么就导致虚拟DOM中的value值一直不改变，再更新底层DOM的input value值时，input value值也就变成了一成不变的值</p><p><img src="https://i.loli.net/2018/02/22/5a8e698e6b55b.jpg" alt="notsetState"></p><p>这样就会出现，当虚拟DOM中指定value值为“123”，那么无论输入多少次后，底层DOM的input value值最终也仍然会被更新为“123”，即使接收到了输入时event.target的value值为“1231”</p><h2 id="不受控组件"><a href="#不受控组件" class="headerlink" title="不受控组件"></a>不受控组件</h2><p>受控组件讲了很多的东西，都是在说它是如何被控制的，控制后会发生什么现象和有什么坑。而不受控组件就是说它不会被我们控制，其特征就和我们平常使用的表单组件一样</p><blockquote><p>在大多数情况下，我们推荐使用受控组件来实现表单。在受控组件中，表单数据由 React 组件负责处理。另外一个选择是不受控组件，其表单数据由 DOM 元素本身处理。</p><footer><strong>http://www.css88.com/react/docs/forms.html</strong></footer></blockquote><p>官方文档中提及到，不受控组件的表单数据由DOM元素本身处理（即使这在react中不被推荐），这就证明它的特征和我们平常使用的表单元素差不多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit(event) &#123;</span><br><span class="line">  alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.input.value);</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Name:</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>先不管<code>ref</code>的属性，在这个例子中，我们看到其与受控组件最大的不同在于，我们并没有为其定义value属性。根据官方文档所说，<code>其表单数据由 DOM 元素本身处理</code>，也就是说，此时value属性的值是由正常的html元素来处理，即我们一般理解的，value属性的值会自动等于输入的值，而事实上也正是这样的，这个例子中最后提交的input的value值就是输入框中输入的内容。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote><p>ref属性是react组件自带的属性，它其实是一个回调函数，传入的参数就是某个组件的实例，这个回调函数只有在<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componnetWillUnmount</code>时调用，在前两种情况中，传入的参数是一个实例，在卸载时调用时传入的是null。</p></blockquote><p>在上面例子的代码中，结合ref理解的意思就是，当这个组件被挂在时，用this.input来指向这个input实例（这是一个对象赋值），当表单提交的时候，获取this.input.value就是input实例的value。<strong>ref是一个突破单向数据流的一个用法，目的就是为了可以让父级或祖先级的一个组件可以直接获取某一个子类组件的实例，从而直接控制它的状态</strong>，官方推荐在使元素自动聚焦时使用。</p><p>上面的代码如果做部分修改，修改成以下这样，就会失去效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit(event) &#123;</span><br><span class="line">  alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.input_value);</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Name:</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input_value = input.value&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我在ref回调函数中，直接用this.input_value等于input.value，看似和之前的代码没太大不同，只是将取value的操作提前了，但是这就会导致最后提交表单时提交的value值为空。原因在于，上面我们提过，ref只有在<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componnetWillUnmount</code>时调用，最后一个我们可以忽略，而在这段代码中，由于我们没有更新state，我们也没有引用外部传入的props，因此不会出现更新的情况，因此ref只会在组件挂载的时候被调用，此时input.value自然而然是空的。而与之前的代码不同在于，这次是基本类型的值赋值，而上一次是对象引用赋值，就是说上一次我们的<code>this.input</code>记录的是input实例的引用，input实例发生改变，我们可以在<code>this.input</code>中访问查看到，但我们这次是简单的值赋值，就是赋了值之后就不会再受之前的值影响了，所以一直为空。</p><h2 id="受控组件和不受控组件转换"><a href="#受控组件和不受控组件转换" class="headerlink" title="受控组件和不受控组件转换"></a>受控组件和不受控组件转换</h2><p>其实方法很简单，通过上述对比我们就知道，两者最大的不同在value属性，假如我们将受控组件的value设成<code>null</code>或者<code>undefined</code>，那那么受控组件就会变成不受控组件了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入首先被锁定，但在短暂的延迟后可以编辑</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"hi"</span> /&gt;</span>, mountNode);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">setTimeout(function() &#123;</span></span><br><span class="line">  ReactDOM.render(&lt;input value=&#123;null&#125; /&gt;, mountNode);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，总结一下就是说受控组件之所以受控，就是因为其value属性和我们平常html表单元素的value属性是不太一样的，它一经赋值，如果不被修改，那么表单元素的value值也就跟着不会被修改，这就是受控组件。而不受控组件就像我们一般的平常使用的html表单元素，它的value属性是会自动与输入的值相等的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.css88.com/react/" target="_blank" rel="noopener">http://www.css88.com/react/</a> —— 官方文档</li><li><a href="https://www.cnblogs.com/purpleraintear/p/6040030.html" target="_blank" rel="noopener">https://www.cnblogs.com/purpleraintear/p/6040030.html</a> ——某位大牛博客</li><li>小时光茶社（Tech Teahouse）—— Tencent QQ会员技术团队。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习过react的人都知道，react中有两个概念——受控组件和不受控组件，这两个组件大部分是值表单控件，受控和不受控最大的区别在一个属性——value，在入坑react的时候，一开始很容易被这个value属性坑掉，因为它和我们之前学过的html元素中的value属性不太相
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="reactJs" scheme="http://yoursite.com/tags/reactJs/"/>
    
  </entry>
  
  <entry>
    <title>reactJs props和state的区别</title>
    <link href="http://yoursite.com/2017/12/14/react-prop-state/react-prop-state/"/>
    <id>http://yoursite.com/2017/12/14/react-prop-state/react-prop-state/</id>
    <published>2017-12-14T09:11:30.000Z</published>
    <updated>2018-02-14T10:02:59.715Z</updated>
    
    <content type="html"><![CDATA[<p>一开始学习react的时候都会有一个疑惑，就是prop属性和state属性之间的区别是什么，其实网上已经有很多大牛进行了总结，但是如果不自己尝试写一写的话，感觉不会特别地懂。</p><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote><p>Props，即属性(Property)， 在代码中写作 props ， 故可用 props 指代 properties</p></blockquote><p>以上是选自<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">官方文档</a>的一句话，props就是一个react组件中的属性值，可以类比于html元素中的属性。其用法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123; <span class="comment">//函数式组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123; <span class="comment">//类组件</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种组件的等价声明方式，就像构造函数一样，在创建一个组件的时候传入一个参数，该参数就是该组件的props属性值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Eric"</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>以上代码以<a href="http://www.runoob.com/react/react-jsx.html" target="_blank" rel="noopener">JSX</a>语法声明welcome为Welcome组件，并且在创建Welcome组件的时候传入Eric值为其属性name的值。</p><h3 id="props的特性"><a href="#props的特性" class="headerlink" title="props的特性"></a>props的特性</h3><p>从用法可以看出来，props是不能自己创建的，必须是由外部传参而生成的，即不能调用<code>this.props.name=xxx</code>来声明一个name属性值（类似地，就不能调用<code>this.props.name=xxx</code>对props值进行修改），必须是在创建组件的时候从外部指定一个特定的值，如上面代码所示的”Eric”，当然也可以是一个变量值</p><blockquote><p>官方文档里面有说过“props放初始化数据，一直不变的”</p></blockquote><p>其实这句话说的不完全，props不一定一直不变，而是说不能自己改变，官方文档指的“一直不变”的意思是<strong>外部每次传进来的props值，在组件内部是一直不会改变的，除非外部重新传来一个新的props值</strong>（这里下面再详细解释）</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote><p>以上说过props值是不能被自身改变的，因此一个可以被自身改变的值就应运而生，就是state</p></blockquote><p>在这里出现了第一个state和props非常不同的地方，就是state可以被自身改变，其用法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">//声明并初始化state中的值</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数<code>constructor</code>中声明并初始化state值，则可以在return的react组件中绑定state的值。那么如果要改变的话该怎么办呢，就是要使用<code>setState</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">//声明并初始化state中的值</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    <span class="comment">//声明响应函数</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2 onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里添加一个点击响应函数handleClick负责响应h2的点击事件，handleClick中利用setState更新date的时间，当鼠标点击h2标签时，h2中的内容就会相应地改变，这就是state的作用</p><h2 id="Props和state的区别"><a href="#Props和state的区别" class="headerlink" title="Props和state的区别"></a>Props和state的区别</h2><p>到了重点部分，通过列举它们的用法应该可以或多或少看到了props和state的区别了，但是还是要归纳一下，用于理解</p><blockquote><p>props是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件。而state代表的是一个组件内部自身的状态（可以是父组件、子孙组件）</p></blockquote><p>摘自网上大牛的一句话，这句话的意思用代码理解是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">//假设传进来的props中有name</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Container组件中包含着3个Component组件，在传参过程中Component的name值都是由Container传递的，就是说每个组件的props都是由父组件传递过来的，因为自身是没办法创建props属性的，而state属性则是可以自身创建的，我们可以修改下例子也一样可以用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Eric"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.state.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.state.name&#125; /&gt;</span><br><span class="line">        &lt;Component name=&#123;<span class="keyword">this</span>.state.name&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这说明父组件创建的state值可以通过子组件的props传递给子组件，这也解释了上面大牛说的那句话。</p><p>总结一下，props和state第一个不同就是“props属性是父组件或外部传参传递进来，而state属性是组件自己声明创建的”</p><blockquote><p>props放初始化数据，一直不变的，state就是放要变的</p></blockquote><p>这是大牛说的第二点，理解起来就很容易了，因为上面也有提到过，就是props值自身是没办法改变的，而state值自身就可以通过<code>setState</code>进行修改</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实并不是总结起来发现也不是特别难，好像最后浓缩成了两点</p><ul><li>props不能自身创建，需要外部或父组件传递，state只能由自身创建</li><li>自己的props不能被自己修改，自己的state值则能可以调用<code>setState</code>修改</li></ul><p>其实在使用的时候，props和state经常一起混合使用，比如一些state状态提升之类的状况用法，非常的灵活，还是要多实践敲敲bug才行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始学习react的时候都会有一个疑惑，就是prop属性和state属性之间的区别是什么，其实网上已经有很多大牛进行了总结，但是如果不自己尝试写一写的话，感觉不会特别地懂。&lt;/p&gt;
&lt;h2 id=&quot;Props&quot;&gt;&lt;a href=&quot;#Props&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="reactJs" scheme="http://yoursite.com/tags/reactJs/"/>
    
  </entry>
  
  <entry>
    <title>原生Js和Jquery获取html元素属性的方式</title>
    <link href="http://yoursite.com/2017/12/04/%E5%8E%9F%E7%94%9Fjs%E5%92%8Cjquery%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F/%E5%8E%9F%E7%94%9FJs%E5%92%8CJquery%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/04/原生js和jquery获取元素属性的方式/原生Js和Jquery获取元素属性的方式/</id>
    <published>2017-12-04T14:41:08.000Z</published>
    <updated>2018-02-14T10:03:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>在html里面，html元素属性有很多种，比如img元素自带的就会有src、title、placehold等等属性。当然，html对于自定义属性也是非常的开方，开发者可以随意在html元素里面加任何名字的属性并赋值，或者在js中动态加入，html5还引入了dataset属性来规范自定义属性的声明和使用，但是在Js和Jquery中获取html元素属性的方法有很多种，不同方法得到的效果也不尽相同，因此想深入分析区分一下。</p><h2 id="原生JS获取html元素属性"><a href="#原生JS获取html元素属性" class="headerlink" title="原生JS获取html元素属性"></a>原生JS获取html元素属性</h2><p>先不考虑html5的dataset，考虑以下情况：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span> <span class="attr">xsrc</span>=<span class="string">”img/img.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在原生Javascript有两种获取自定义的xsrc属性的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xscr = img.xsrc; <span class="comment">//无法获取到html元素中的自定义属性</span></span><br><span class="line"><span class="keyword">var</span> xscr = img.getAttribute(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到html元素中的自定义属性</span></span><br><span class="line"><span class="keyword">var</span> src = img.src;</span><br><span class="line"><span class="keyword">var</span> src = img.getAttribute(<span class="string">"src"</span>);</span><br></pre></td></tr></table></figure><p>经试验，只有getAttribute函数时可以获取到img元素中定义的xsrc元素，直接用img.xsrc来访问xsrc属性是不行。但两种方法都可以获取到img原生自带的src属性。</p><h2 id="Jquery获取html元素属性"><a href="#Jquery获取html元素属性" class="headerlink" title="Jquery获取html元素属性"></a>Jquery获取html元素属性</h2><p>还是考虑以上的img元素，jquery获取其元素的方法也是有两种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到写在html元素中的自定义属性</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"xsrc"</span>); <span class="comment">//不可以获取到对象中的自定义属性</span></span><br><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"src"</span>); <span class="comment">//可以获取到写在html元素中的原生属性</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"src"</span>); <span class="comment">//可以获取到对象中的部分原生属性</span></span><br></pre></td></tr></table></figure><p>经过试验可以发现，attr()方法比较强大，它可以获取到html元素中的自定义属性和原生属性，但是prop()方法却无法保证获取到这两种属性（<em>注：prop获取原生属性时，不能百分百返回在html元素中设置的值，比如在获取src值时，它返回的不是xxx，而是文件路径+xxx，但当获取title值时，却能正确返回，因此在获取html元素中的原生属性时，尽量不要使用prop元素</em>）</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h3 id="动态加入自定义属性"><a href="#动态加入自定义属性" class="headerlink" title="动态加入自定义属性"></a>动态加入自定义属性</h3><p>其实以上获取的自定义属性都是在html元素中定义好的，那还有一种情况就是没有在html元素中提前定义好，而是用js动态为某个html元素对象定义属性，那么在这种情况下，该怎么获取到这个自定义属性?</p><p>考虑以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line">img.hsrc = <span class="string">"ssss"</span>;</span><br></pre></td></tr></table></figure><p>我在JS中利用DOM获取到img元素的Element对象，然后为这个对象动态地加入hsrc属性，并赋值为ssss，此时我再用上述的所有方法获取该自定义属性值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hsrc = img.hsrc; <span class="comment">//可以获取到hsrc值</span></span><br><span class="line"><span class="keyword">var</span> hsrc = img.getAttribute(<span class="string">"hsrc"</span>); <span class="comment">//不能获取到hsrc值</span></span><br><span class="line">$(<span class="string">"img"</span>).attr(<span class="string">"xsrc"</span>); <span class="comment">//不能获取到hsrc值</span></span><br><span class="line">$(<span class="string">"img"</span>).prop(<span class="string">"xsrc"</span>); <span class="comment">//可以获取到hsrc值</span></span><br></pre></td></tr></table></figure><p>经试验发现，只有prop()方法和直接获取元素的方法可以访问到js动态声明的属性值，而attr()方法和getAttribute()方法都无法访问到该属性</p><h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p>可能是由于这种自定义元素的获取容易混淆，所以html5加入了一个dataset来规范自定义元素的声明，不过dataset是一个只读的属性，它一般只用来在html元素中使用data-*来声明自定义属性，不能用来动态新增或修改属性值，其用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-xsrc</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>获取时，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xsrc = img.dataset.xsrc;</span><br><span class="line"><span class="keyword">var</span> xsrc = $(<span class="string">"img"</span>).data(<span class="string">"xsrc"</span>);</span><br></pre></td></tr></table></figure><p>刚说过原生的dataset属性是一个只读属性，但是Jquery的data函数不仅是可读的，而且是可写，用法就是在第二个参数中传入一个新的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"img"</span>).data(<span class="string">"xsrc"</span>, <span class="string">"1231123"</span>); <span class="comment">//不仅可以修改一个属性值，还可以创建一个属性值</span></span><br></pre></td></tr></table></figure><p>这种情况下，data函数的原理是什么呢？既然原生js中dataset属性是只读的，那么data()函数就不是通过dataset属性来实现的，而且data()函数不是真正的修改html元素里的data-*属性，而是通过覆盖已存在的值，只有再调用data()函数取相同name的属性时，才会得到新的覆盖的值，removeData()可以将这个新的覆盖值删掉，实例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"1231"</span> xsrc=<span class="string">"xixixi"</span> title=<span class="string">"111"</span> data-xtitle=<span class="string">"110"</span>&gt;</span><br><span class="line">$(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>, <span class="string">"123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>)); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(img.dataset.xtitle); <span class="comment">//110</span></span><br><span class="line">$(<span class="string">"img"</span>).removeData(<span class="string">"xtitle"</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"img"</span>).data(<span class="string">"xtitle"</span>));  <span class="comment">//110</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>原生js：<ul><li>img.xsrc无法获取到html元素中的自定义属性</li><li>img.getAttribute(“xsrc”)可以获取到html元素中的自定义属性</li></ul></li><li>Jquery：<ul><li>$(img).attr(“xrc”)可以获取到写在html元素中的自定义属性</li><li>$(img).prop(“xrc”)可以获取到对象中的自定义属性</li></ul></li></ol><p>在js代码中为某个html的对象动态定义属性时，如img.hsrc=”xxx”时，img.hsrc可以直接获取到该自定义属性，$(img).prop(“hsrc”)也可以获取到，其它两个不行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在html里面，html元素属性有很多种，比如img元素自带的就会有src、title、placehold等等属性。当然，html对于自定义属性也是非常的开方，开发者可以随意在html元素里面加任何名字的属性并赋值，或者在js中动态加入，html5还引入了dataset属性
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
  <entry>
    <title>JSONP的使用</title>
    <link href="http://yoursite.com/2017/11/24/JSONP/"/>
    <id>http://yoursite.com/2017/11/24/JSONP/</id>
    <published>2017-11-24T15:21:40.000Z</published>
    <updated>2018-02-24T16:26:32.796Z</updated>
    
    <content type="html"><![CDATA[<p>所有前端开发者应该都知道，浏览器的网络请求存在跨域限制，目的就是为了保护资源，增强安全性，于是就有了一些CORS的协议方法来解决跨域的问题，但这些主要都是面向服务端的，前端也有一个很热门的做跨域的东西——JSONP。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><blockquote><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题</p></blockquote><p>JSONP并不是一种数据结构或是什么库和函数，只能说是一种方法或者技术，其实和JSON的关系并没有它们的名称看起来那么相近，以我的理解只是因为在使用这种技术的时候，很多时候会用到JSON对象进行传参（但并不一定需要用到）</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>在理解JSONP之前，我们需要知道在html里面其实自带的有几个元素就是可以发跨域请求的，这几个元素的共同点就是都有<code>src</code>属性，比如<code>img</code>、<code>iframe</code>、<code>script</code>，这些元素它们的请求都具有跨域性，可能很多人平时用没有太多注意，但是很容易举例发现它们的跨域性，比如一张图片，它可以指向百度图片的一个链接并成功获取。</p><p>JSONP就是建立在这些自带跨域性的元素的基础上形成的技术，但是前提一定要记住<strong>JSONP一定是get请求！！！JSONP一定是get请求！！！JSONP一定是get请求！！！</strong> ，因为<code>src</code>属性发起的就是get请求</p><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>聪明的前辈们想到，当需要跨域的时候，我们就可以新建一个<code>img</code>、<code>iframe</code>或<code>script</code>元素并指定<code>src</code>路径来发起get请求，但是假如我们需要在get请求发送成功并得到服务器反馈时，调用一个回调函数来处理服务器返回的参数该怎么办？</p><p>这时候，<code>script</code>元素闪亮登场，我们先想一想当<code>script</code>元素的<code>src</code>指向一个js文件时，那么就相当于会将该js文件中的代码拷贝到当前的文档中执行。JSONP就是利用这种思想，假设我们让服务端返回一段可执行的js代码，那么当<code>script</code>加载完后，本地就会执行这段代码，相当于执行一个回调函数一样。</p><p>下面的例子是以node.js为服务端写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js，监听本地的8888端口</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/jsonp"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.send(<span class="string">"console.log('hhh')"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;script src=<span class="string">"http://localhost:8888/jsonp"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当运行上述代码时，当<code>script</code>加载成功后，浏览器控制台就会输出“hhh”，原因就是此时<code>script</code>中包含了<code>res.send()</code>回来的代码，然然后浏览器就把它当成js脚本执行了</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>大致了解了JSONP之后，那应该再了解一下最正统的做法了（可以说是前辈们约定俗成的规矩）。上面的例子可以看到，只要在服务端加入Javascript的代码，那么这段代码就相当于我们的回调函数一样，在浏览器加载脚本成功后执行，这样就会有一个困扰：如果我们的回调函数很复杂，远远没有<code>console.log()</code>这么简单，那岂不是服务端要写很多响应的js代码，而且前后端的工作就耦合混杂在了一起？</p><p>为了解决这个问题，聪明的前辈们想到可以使用函数来解决，比如在前端html文档中实现定义好了一个名叫<code>handle()</code>的函数，然后服务端返回一个<code>handle()</code>的字符串，那么前端在响应成功之后，不就可以调用了吗？事实也的确如此</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js，监听本地的8888端口</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/jsonp"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.send(<span class="string">"handle()"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hhh"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/localhost:8888/</span>jsonp<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码依然会在浏览器控制台输出“hhh”，但是调用的方式和之前的有点不同，这里是因为第二个script脚本在接受到服务器响应后，调用了<code>res.send()</code>传回来的<code>handle()</code>函数</p><p>但是，JSONP还没那么简单，因为现在还没考虑传参，在我们平常的请求中，前端和服务端都会有数据的交流，前端向后端的get请求传参较为容易，直接就是在<code>src</code>的路径后加入参数就可以了，比如<code>http://localhost:8888/jsonp?name=Eric</code>，但如果服务端要向前端返回一些数据，该怎么传递这个参数呢？说到底，就是<strong>拼接字符串</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js，监听本地的8888端口</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/jsonp"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = req.query.name;</span><br><span class="line">res.send(<span class="string">"handle('"</span> + name + <span class="string">"')"</span>); <span class="comment">//前后有个单引号，因为name传进去是一个字符串</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hhh "</span> + name); <span class="comment">//hhh Eric</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/localhost:8888/</span>jsonp?name=Eric<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码输出为”hhh Eric”，其实就是在res返回的时候在拼接了一个变量作为将要调用的函数的参数。假如服务端要传一个较为复杂的参数时，这样就可以用JSON进行传递了，因为JSON有个<code>JSON.stringify()</code>函数，很轻松地就会将对象变成字符串的形式，然后与函数名和括号进行拼接，<em>我想这大概就是JSONP和JSON最有关系的地方了</em>。</p><p>最后还有一点就是，假如服务端预先不知道浏览器回调函数的函数名，如这里服务端并不知道有<code>handle()</code>这个函数名，那应该怎么办呢？这就是前面提到的一个约定俗成的规矩，就是前端在<code>src</code>属性的路径后面加入一个名为<code>callback</code>，值为响应函数函数名的键值对，如<code>http://localhost:8888/jsonp?callback=handle</code>，这样服务端调用只要查询callback字段（因为是一个约定俗称的字段，所以在实际开发中，前后端的工程师还可以指定其它名字来指定这个函数名的键值名称，比如call、callbackfunc等等，只要前后端工程师一起规定好就行），就会知道回调函数的函数名是什么了，然后再进行字符串拼接就可以了，最后来一个比较完整的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js，监听本地的8888端口</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/jsonp"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">"name"</span> : req.query.name,</span><br><span class="line">    <span class="string">"option"</span>: <span class="string">"I am JSON"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> func = req.query.callback;</span><br><span class="line">res.send(func+<span class="string">"("</span> + <span class="built_in">JSON</span>.stringify(json) + <span class="string">")"</span>); <span class="comment">//JSON.stringify会自动为JSON对象字符串加上前后两个大括号&#123;&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hhh "</span> + data.name); <span class="comment">//hhh Eric</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/localhost:8888/</span>jsonp?callback=handle&amp;name=Eric<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出还是“hhh Eric”，原因上面已经说了。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3><p>既然JSONP这么实用这么火，那Jquery插件也是支持了这种东西，在Jquery发送ajax的请求中，将<code>dataType</code>设成<code>jsonp</code>就可以告诉服务器这是一个JSONP请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"xxxx"</span>,</span><br><span class="line">  type: <span class="string">"GET"</span>, <span class="comment">//JSONP一定是get请求</span></span><br><span class="line">  dataType: <span class="string">"jsonp"</span>, <span class="comment">//指定服务器返回的类型</span></span><br><span class="line">  jsonp: <span class="string">"callback"</span>, <span class="comment">//指定url参数中回调函数名的键值名称，默认就为callback</span></span><br><span class="line">  jsonpCallback: <span class="string">"handle"</span>, <span class="comment">//指定回调函数的函数名，这个可写可不写，因为Jquery会自动执行success回调函数来处理</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Jquery把JSONP纳入到了ajax请求中，尽管它们并不是一样东西，但是用的爽就行了，唯一和原生使用的时候不同的就是，这里我们不用显式地写一个handle回调函数了，因为Jquery会自动帮我们用success回调函数帮我们执行。</p><h3 id="node-js-express"><a href="#node-js-express" class="headerlink" title="node.js express"></a>node.js express</h3><p>node.js的express框架也实现了JSON的拓展，那就是response对象可以调用<code>response.jsonp()</code>，这样把要传给浏览器的参数放到<code>jsonp()</code>函数中，express就会帮我们完成拼接字符串的任务，用这个函数重写上面的例子会得到一样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js，监听本地的8888端口</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/jsonp"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">"name"</span> : req.query.name,</span><br><span class="line">    <span class="string">"option"</span>: <span class="string">"I am JSON"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> func = req.query.callback;</span><br><span class="line"><span class="comment">//res.send(func+"(" + JSON.stringify(json) + ")");</span></span><br><span class="line">  res.jsonp(json); <span class="comment">//不用自己拼接字符串了，我们只需要传参即可</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hhh "</span> + data.name); <span class="comment">//hhh Eric</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/localhost:8888/</span>jsonp?callback=handle&amp;name=Eric<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JSONP不是JSON、也不是AJAX，但和它们确实有一点的关系，最主要的就是JSONP像一种hack技术一样，利用<code>script</code>标签解决了跨域的问题，而且很多js的插件和库都给了它一些支持，方便我们使用它进行跨域请求，总的来说还是一个好东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有前端开发者应该都知道，浏览器的网络请求存在跨域限制，目的就是为了保护资源，增强安全性，于是就有了一些CORS的协议方法来解决跨域的问题，但这些主要都是面向服务端的，前端也有一个很热门的做跨域的东西——JSONP。&lt;/p&gt;
&lt;h2 id=&quot;JSONP&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
  <entry>
    <title>getBoundingClient</title>
    <link href="http://yoursite.com/2017/11/11/getBoundingClient/getBoundingClientRect/"/>
    <id>http://yoursite.com/2017/11/11/getBoundingClient/getBoundingClientRect/</id>
    <published>2017-11-11T04:49:55.000Z</published>
    <updated>2018-02-14T11:34:27.205Z</updated>
    
    <content type="html"><![CDATA[<p>对于DOM中的盒模型，学习前端的人肯定再熟悉不过，在盒模型中除了margin、padding这些基本的值以外，还会有offsetTop、offsetLeft、clientTop、clientLeft这些值，但其实还有一个容易让人忽略，但非常实用的值或者说函数，就是getBoundingClient</p><h2 id="getBoundingClient语法"><a href="#getBoundingClient语法" class="headerlink" title="getBoundingClient语法"></a>getBoundingClient语法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rectObject = object.getBoundingClientRect();</span><br></pre></td></tr></table></figure><p>返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合 。</p><p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rectLeft = object.getBoundingClientRect().left;</span><br><span class="line">rectRight = object.getBoundingClientRect().right;</span><br><span class="line">rectTop = object.getBoundingClientRect().top;</span><br><span class="line">rectBottom = object.getBoundingClientRect().bottom;</span><br></pre></td></tr></table></figure><h3 id="比较offsetTop、offsetLeft"><a href="#比较offsetTop、offsetLeft" class="headerlink" title="比较offsetTop、offsetLeft"></a>比较offsetTop、offsetLeft</h3><blockquote><p>刚刚上面提到了getBoundingClientRect()返回的值都是相对视口而言的，那么我们就会想起offsetLeft、offsetTop，那么这两个属性有什么不同呢，还是说它们就是一样的呢？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 400px; background-color: #aaa; margin: 40px;"</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().top); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().left); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetTop); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetLeft); <span class="comment">//40</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在body元素下直接定义了一个class为test的div标签，然后输出div的top、left值和offsetTop和offsetLeft的值发现它们都是40，那是不是说明它们是一样的呢？我们修改一下代码看看</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 400px; margin: 40px; position: relative;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 100%; background-color: #aaa;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().top); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.getBoundingClientRect().left); <span class="comment">//40</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetTop); <span class="comment">//0</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(test_div.offsetLeft); <span class="comment">//0</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到，此时offsetTop和offsetLeft都会变成了0，因为test_div有了一个非static布局的父元素（<strong>注意一定是非static布局的父元素，否则offsetTop和offsetLet依然是会穿过这个父元素，得到的是相对于整个document文档的偏移量</strong>），所以可以发现offsetTop和offsetLeft得到的是当前元素相对于第一个非static布局的祖先元素的偏移值。而getBoundingClientRect()得到的top、left值则依然是40，因此可以进一步说明getBoundingClientRect()是相对于视口的，和它的父元素无关。</p><blockquote><p>那么如果还是以第一个例子为例，当div元素是body的直接子元素时，offsetTop和getBoundingClientRect().top得到的值就完全相同了吗，此时都是相对于视口而言的吗？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; div.length; ++i) &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].getBoundingClientRect().top);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].getBoundingClientRect().left);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].offsetTop);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(div[i].offsetLeft);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>都过试验，可以发现它们的值都是一样的，但如果到了这里就断定它们是一样的那就错了，因为现在页面没有滚动，当页面有滚动的时候会发生什么情况？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"background-color: #aaa; height: 400px; margin: 40px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test_div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"pagescrollTop: "</span> + <span class="built_in">document</span>.documentElement.scrollTop); <span class="comment">//100</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"test_div top:"</span> + test_div.getBoundingClientRect().top); <span class="comment">//-60</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"test_div offsetTop"</span> + test_div.offsetTop); <span class="comment">//40</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改了输出的代码，以第一个div作为观察对象，当页面出现滚动时，可能会出现以下现象，页面向下滚动了100的距离，此时test_div的top值为-60，而offsetTop的值依然为40，大家可以参照下面的图理解下此时的情况，此时test_div的上边缘已经超出了视口，在视口的上方，上边缘与视口上方的距离为60，而整个文档页面的上边缘也超出了视口，根据页面的滚动值可以知道，此时文档页面的上边缘超出视口的距离为100，而offsetTop的值就是test_div在文档页面的偏移量，因此不会改变，一直为40</p><p><img src="https://i.loli.net/2018/02/14/5a841eb3ba9c2.jpg" alt="example"><br></p><p>因此，比较出它们两者的区别:</p><ul><li>getBoundingClient()是相对于视口的偏移量，和它的父元素无关，不仅可以取正值，当超出视口上边缘的时候，可以取到负值</li><li>offsetTop和offseLeft是相对于第一个非static的祖先元素的偏移量，它是一个静态固定的值，除非文档重绘，否则它不会改变，一般为正值，除了margin为负值的情况</li></ul><h2 id="getBoundingClient-的真正用途"><a href="#getBoundingClient-的真正用途" class="headerlink" title="getBoundingClient()的真正用途"></a>getBoundingClient()的真正用途</h2><blockquote><p>上面说了如此多都是在介绍getBoundingClient()的语法，还有和offset的区别，但仅仅知道这些是不够的，还需要知道getBoundingClient常用在什么情况</p></blockquote><p>在瀑布流的布局中，常常会有两种情况，要么是当文档滚动触底的时候，动态加载一些新的图片并追加一下img元素，要么就是预先已经追加了很多img元素和其对应的图片路径，但只有当img元素出现在视口中时才开始加载图片。</p><ul><li>对于第一种情况，利用document.documentElement.offsetHeight、document.documentElement.scrollTop和document.documentElement.clientHeight（或document.body.clientHeight）就可以判断触底然后加载，不需要用到getBoundingClient()</li><li>对于第二种情况，就需要监听当页面在滚动时，判断每个img元素是否已经处于视口中，这种情况getBoundingClient()就十分有用了</li></ul><p>先上代码，其实并不难</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placehold.jpg"</span> <span class="attr">xsrc</span>=<span class="string">"http://domain.com/path/img.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; ++i) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(imgs[i].getBoundingClient().top &gt;=<span class="number">0</span> &amp;&amp; imgs[i].getBoundingClient.top &lt;= <span class="built_in">document</span>.documentElement.clientHeight) &#123; <span class="comment">//判断在视口中</span></span></span><br><span class="line"><span class="javascript">          imgs[i].src = imgs[i].getAttribute(<span class="string">"xsrc"</span>); <span class="comment">//赋值给src</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们假设我们已经用ajax或者其它方式请求到了多个图片的路径，然后我们动态地将img元素追加到了文档中，但是我们不立即设置img元素的src值为该图片路径，而是将这个路径值存在img元素的xsrc属性中（属性名可以自己定义，无关紧要）。因为我们知道<strong>给img设置src值后就会马上向服务器请求改图像的资源</strong>，假如图片很多并且都很大，就会很耗费资源，所以可以考虑，只有当我们滚动页面显示到了对应的img元素时才将src设为对应的图像路径去请求资源，这样就会相对减少不必要的请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>getBoundingClient()函数只要是用于返回一个元素的rect矩形模型对于视口的top、left、right、bottom值，我们可以利用getBoundingClient函数来实现判断一个元素是否处于视口中，即当前是否被显示在浏览器的窗口中，从而进行一系列的操作，比如将图片加载出来等等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于DOM中的盒模型，学习前端的人肯定再熟悉不过，在盒模型中除了margin、padding这些基本的值以外，还会有offsetTop、offsetLeft、clientTop、clientLeft这些值，但其实还有一个容易让人忽略，但非常实用的值或者说函数，就是getBo
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://yoursite.com/2017/11/05/flex/"/>
    <id>http://yoursite.com/2017/11/05/flex/</id>
    <published>2017-11-05T05:01:07.000Z</published>
    <updated>2018-03-05T06:09:42.414Z</updated>
    
    <content type="html"><![CDATA[<p>Flex布局css一个非常流行且有用的弹性布局，它的一些教程来来回回看了几遍，自己也经常使用这个布局，但是面试的时候面试官提出了几个问题，才让我发现其实自己还不是对和这个布局特别熟，因此想markdown一下，顺便分享一下里面的坑</p><h2 id="Flex语法"><a href="#Flex语法" class="headerlink" title="Flex语法"></a>Flex语法</h2><blockquote><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><footer><strong>http://www.runoob.com/w3cnote/flex-grammar.html</strong></footer></blockquote><p>以下是父元素容器设置的属性：</p><ul><li>display:flex——定义容器为flex弹性容器</li><li>flex-direction——定义弹性的方向</li><li>flex-wrap——定义能否换行</li><li>flex-flow——flex-direction属性和flex-wrap属性的简写形式</li><li>justify-content——子元素在主轴中的相互间距</li><li>align-items——子元素在交叉轴上如何对齐</li><li>align-content——多行子元素的对齐方式</li></ul><p>父元素各个属性并不详细解释了，因为主要遇到的坑在于子元素的属性：</p><ul><li>order——定义子元素在主轴的位置顺序</li><li>flex-grow——定义子元素在主轴剩余空间的分配系数</li><li>flex-shrink——定义子元素在主轴的缩减系数</li><li>flex-basis——定义子元素一开始的固定值</li><li>flex——flex-grow属性、flex-shrink属性和flex-basis属性的缩写</li><li>align-self——定义子元素在交叉轴的对齐方式（覆盖align-items）</li></ul><p>order属性和align-self属性都很容易理解和使用，最大的坑是在于缩写属性flex的使用，可能很多在用flex布局的人都和我一样还不是很懂，<code>flex:1</code>和<code>flex:auto</code>，<code>flex:0</code>和<code>flex:none</code>的区别在哪</p><h2 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h2><blockquote><p>Flex属性是flex-grow属性、flex-shrink属性和flex-basis属性的缩写，其默认值为0 1 auto</p></blockquote><p>在我们书写flex属性的时候，我们并不会真的为它显式地定义3个值，一般就直接写一个值，比如<code>flex:1</code>、<code>flex:0</code>，或者<code>flex:auto</code>、<code>flex:none</code>。在使用的过程中，我们可能没有遇到那么多的坑，只是大致知道用<code>flex:1</code>和<code>flex:auto</code>可以实现一个自动填充补满剩余空间的功能，而<code>flex:0</code>和<code>flex:none</code>则将这个元素固定。但当我们写一个更复杂、搭配其它样式写的时候，可能会发现效果不如预期，因此我们要捋一捋它们真正的含义（即flex包含的3个值到底是什么）</p><ul><li><p>当 flex 取值为 none，则计算值为 0 0 auto</p><p> ——这意味着这个元素，不仅不会分配填充剩余空间，而且还不会在空间不够时减少，如果父元素长度不够，而且定义了<code>overflow:hidden</code>，那么超那么超出的子元素就会被隐藏掉</p></li><li><p>当 flex 取值为 auto，则计算值为 1 1 auto</p><p>——和none相反，这个元素既会分配空间，又会在空间不够时减少自己的长度，因为<code>flex-grow</code>和<code>flex-shrink</code>为1</p></li><li><p>当 flex 取值为一个非负数字，则该数字为<code>flex-grow</code>值，<code>flex-shrink</code>取 1，<code>flex-basis</code>取 0%</p><p>——因此，<code>flex: 0</code>和<code>flex: 1</code>的共同点是<code>flex-shrink</code>取1，<code>flex-basis</code>取 0%，只是<code>flex-grow</code>值不同，我们先不讨论<code>flex-basis</code>取 0%效果是什么，先继续讨论flex</p></li><li><p>当 flex 取值为一个长度或百分比，则视为<code>flex-basis</code>值，<code>flex-grow</code> 取 1，<code>flex-shrink</code> 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</p></li><li><p><code>flex-basis</code> 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。<code>flex-basis</code> 规定的范围取决于 box-sizing。这里我们讨论一下 flex-basis 的取值情况和其作用：</p><ul><li><p>auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。</p></li><li><p>content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。</p></li><li><p>百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。</p></li></ul></li></ul><p>以上讲了几种情况，我们可以发现<code>flex: 1</code>与<code>flex: 0</code>，和<code>flex: none</code>与<code>flex: auto</code>最大的不同就在于<code>flex-basis</code>的值，前两者<code>flex-basis</code>的值会变为0%，而后两者<code>flex-basis</code>的值为auto，我们举个例子看看就很清晰了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display: flex; width: 250px; margin: 10px auto;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: red; flex: 0; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: green; flex: 1; display: inline-block;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: blue; flex: 0; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下，会发现结果全是绿色块，原因很简单，就是因为<code>flex: 0</code>的<code>flex-basis</code>值为0%，因此即使定义<code>width: 100px</code>也没有用，元素会被解析成宽度为0，因此中间<code>flex: 1</code>的绿色块就占满了全部</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display: flex; width: 250px; margin: 10px auto;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: red; flex: none; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: green; flex: 1; display: inline-block;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: blue; flex: none; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们把两边改成<code>flex: none</code>，这就是我们所熟悉和期望的布局了，由于<code>flex-basis: auto</code>，因此两边的宽度就是<code>width</code>定义的宽度，变成固定的100px，不伸缩，而中间就自动填满剩余空间，假如我们把修改父元素的样式为<code>width: 200px</code>，这样就没有了剩余空间，绿色快就不会显示出来了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display: flex; width: 250px; margin: 10px auto;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: red; flex: auto; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: green; flex: 1; display: inline-block;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: blue; flex: auto; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们把左右两边的<code>flex</code>属性定义为auto，这样就会直观地发现<code>flex: auto</code>和<code>flex: 1</code>的不同了，由于两边的<code>flex-basis: auto</code>，因此一开始的固定宽度就是它们定义的<code>width: 100px</code>，这样剩余空间就是250 - 100 - 100 = 50，然后由于三个<code>&lt;span&gt;</code>元素的<code>flex-grow: 1</code>，那么它们再平分这个50，最后得到的会是，左右为116.67px，中间为16.67px。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display: flex; width: 250px; margin: 10px auto;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: red; flex: 1; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: green; flex: 1; display: inline-block;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"height: 100px; background-color: blue; flex: 1; display: inline-block; width: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后我们把3个<code>&lt;span&gt;</code>都改为<code>flex: 1</code>，这样最后的效果，就是三个<code>&lt;span&gt;</code>元素平分了250px，因为<code>flex: 1</code>的<code>flex-basis</code>属性为 0%，因此导致两边定义的<code>width: 100px</code>都会失效，所以剩余空间就是250px，所以它们就会平分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写完发现<code>flex</code>确实没有自己一开始想的那么简单，学东西和用东西有时候多想一想会对自己更有帮助，否则自己踩坑后才发现这个东西和自己所想的完全不一样。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.runoob.com/w3cnote/flex-grammar.html——flex布局教程" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/flex-grammar.html——flex布局教程</a></li><li><a href="https://segmentfault.com/q/1010000004080910——segmentfault大牛的回答" target="_blank" rel="noopener">https://segmentfault.com/q/1010000004080910——segmentfault大牛的回答</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flex布局css一个非常流行且有用的弹性布局，它的一些教程来来回回看了几遍，自己也经常使用这个布局，但是面试的时候面试官提出了几个问题，才让我发现其实自己还不是对和这个布局特别熟，因此想markdown一下，顺便分享一下里面的坑&lt;/p&gt;
&lt;h2 id=&quot;Flex语法&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Jquery css()引来的误解</title>
    <link href="http://yoursite.com/2017/11/02/Jquery-css/Jquery-css/"/>
    <id>http://yoursite.com/2017/11/02/Jquery-css/Jquery-css/</id>
    <published>2017-11-02T08:35:59.000Z</published>
    <updated>2018-02-14T11:36:48.352Z</updated>
    
    <content type="html"><![CDATA[<p>由于一开始学习web前端，就去使用Jquery框架了，因此就导致自己对原生js的一些语法产生了误解，留下了很多坑，当自己抛弃Jquery，想用原生的js去写一个简单的网站时就出现了很多问题，其中在动态获取改变元素样式时就遇到了一个值得markdown的问题。</p><h2 id="Jquery-css"><a href="#Jquery-css" class="headerlink" title="Jquery css()"></a>Jquery css()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>); <span class="comment">//获取第一个p元素的color样式值</span></span><br><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>, <span class="string">"red"</span>); <span class="comment">//设置第一个p元素的样式值为red</span></span><br></pre></td></tr></table></figure><p>Jquery.css()获取和设置某个元素的样式，语法很简单</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们知道在DOM标准中，获取元素style的值有两种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.style;</span><br><span class="line"><span class="built_in">document</span>.defaultView.getComputedStyle(element, <span class="literal">null</span>); <span class="comment">//第二个参数指的是伪类，如果不是伪类一般设为null</span></span><br></pre></td></tr></table></figure><p>由此，会出现两个问题：第一个问题是Jquery的css函数其实是原生js的哪种方法包装而成的？第二个问题是原生Js中这两种获取元素style的方法有什么实质性的不同？（而作为一个菜鸟，很可能自然地会以为css()函数就相当于element.style获取样式，两者的效果一样，但事实并不是这样的，也有可能根本不知道getComputedStyle函数的存在）</p><h2 id="Element-style和getComputedStyle"><a href="#Element-style和getComputedStyle" class="headerlink" title="Element.style和getComputedStyle"></a>Element.style和getComputedStyle</h2><h3 id="用法区别"><a href="#用法区别" class="headerlink" title="用法区别"></a>用法区别</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test css<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">p &#123;</span></span><br><span class="line"><span class="undefined">color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>测试style和getComputed<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color); <span class="comment">//输出为空</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">document</span>.defaultView.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>], <span class="literal">null</span>).color); <span class="comment">//rgb(255, 0, 0)</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先解决的是第二个问题，就是这两种样式获取方法的区别在哪，不难发现其实Element.style.color获取到的是行内的样式值（<strong>这真的是个老是坑基础不牢新手的地方，我就被坑了很多次，style值是无法获取到非行内设置的样式值的</strong>），而getComputedStyle是获取到某个元素的全部计算后的样式（计算后的代表不同优先级的同一样式值会取优先级最高的），因此上面的输出style.color由于p元素中没有设置color值，因此输出为空，而getComputedStyle则输出了红色的rgb表示</p><h3 id="比较Jquery-css"><a href="#比较Jquery-css" class="headerlink" title="比较Jquery.css()"></a>比较Jquery.css()</h3><p>回到第一个问题，不妨在上面代码的基础上再加入一行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color); <span class="comment">//输出为空</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.defaultView.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>], <span class="literal">null</span>).color); <span class="comment">//或用getPropertyValue（"color"） 输出rgb(255, 0, 0)</span></span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"p"</span>).css(<span class="string">"color"</span>)); <span class="comment">//rgb(255, 0, 0)</span></span><br></pre></td></tr></table></figure><p>使用css()函数获取到的是rgb(255, 0, 0)，这证明了当<strong>获取样式值</strong>的时候，css()函数其实是和getComputedStyle()元素是一样的。由于getComputedStyle得到的样式值都是只读的，因此我们接下来只要验证一下当用css()函数设置样式值时，是否和element.style设置样式的作用一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>].style.color = green;</span><br><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>, <span class="string">"green"</span>)</span><br></pre></td></tr></table></figure><p>试验之后发现得到的结果都是一样的：<br><br></p><p><img src="https://i.loli.net/2018/02/14/5a841f316c34f.png" alt="img"> <br></p><p>因此，两者在设置样式的效果都是一样的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Jquery.css()函数并不是与原生js的element.style一样的！Jquery.css()函数并不是与原生js的element.style一样的！Jquery.css()函数并不是与原生js的element.style一样的！（重要事情说三遍）</p><ul><li>获取样式时，css()函数与getComputedStyle()函数效果相同（不考虑伪类的情况下，css()函数无法获取伪类样式）</li><li>设置样式时，css()函数与element.style效果相同</li></ul><p>对于一个合格的前端程序员来说，还是要多啃啃书（比如《Javascript权威指南》、《Javascript高级编程》），好好学习一下js，不能只是一个只会用框架的人，“要学会做一个造轮子的人”</p><p><em>补充：既然说到了获取样式，其实在IE9以下的版本，IE只支持currentStyle来实现getComputedStyle的功能（但currentStyle获取不了伪类的样式），但由于currentStyle没有列入DOM标准，这里只说到了DOM标准的两种方法，而IE9已经支持DOM标准了。Jquery框架在前几个版本兼容了IE浏览器的几个较低的版本，而最新的版本已经进行IE低版本(IE6、IE7、IE8)的兼容性处理</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于一开始学习web前端，就去使用Jquery框架了，因此就导致自己对原生js的一些语法产生了误解，留下了很多坑，当自己抛弃Jquery，想用原生的js去写一个简单的网站时就出现了很多问题，其中在动态获取改变元素样式时就遇到了一个值得markdown的问题。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
</feed>
